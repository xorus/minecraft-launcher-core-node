{"version":3,"sources":["definitions.js","scenarios.js","../../node_modules/parcel/src/builtins/bundle-url.js","../../node_modules/parcel/src/builtins/bundle-loader.js","editor.js","../../node_modules/parcel/src/builtins/loaders/browser/css-loader.js","../../node_modules/parcel/src/builtins/loaders/browser/js-loader.js"],"names":["module","exports","bundleURL","getBundleURLCached","getBundleURL","Error","err","matches","stack","match","getBaseURL","url","replace","require","loadBundlesLazy","bundles","Array","isArray","id","length","Promise","resolve","code","LazyPromise","reject","loadBundles","slice","then","all","map","loadBundle","bundleLoaders","registerBundleLoader","type","loader","load","register","bundle","substring","lastIndexOf","toLowerCase","bundleLoader","resolved","catch","e","executor","promise","prototype","onSuccess","onError","self","MonacoEnvironment","getWorkerUrl","moduleId","label","monaco","languages","typescript","typescriptDefaults","setCompilerOptions","target","ScriptTarget","ES2015","allowNonTsExtensions","moduleResolution","ModuleResolutionKind","NodeJs","ModuleKind","CommonJS","key","Object","keys","definitions","modulePath","addExtraLib","models","scenarios","editor","createModel","Uri","parse","create","document","getElementById","model","common","language","theme","automaticLayout","proxyOfAny","Proxy","get","apply","construct","m","console","log","$","dropdown","onChange","src","_","elem","setModel","attr","context","evalInScope","js","eval","call","addCommand","KeyCode","F2","getTypeScriptWorker","worker","uri","client","getEmitOutput","toString","r","outputFiles","text","link","createElement","rel","href","onerror","onload","getElementsByTagName","appendChild","script","async","charset"],"mappings":";AAAAA,OAAOC,QAAQ,6BAAgC,u7DA+D/CD,OAAOC,QAAQ,4BAA+B,gmCAgC9CD,OAAOC,QAAQ,iCAAoC,eAEnDD,OAAOC,QAAQ,2BAA8B,gHAK7CD,OAAOC,QAAQ,4BAA+B,u/CAqC9CD,OAAOC,QAAQ,4BAA+B,k+FAyH9CD,OAAOC,QAAQ,0BAA6B,eAE5CD,OAAOC,QAAQ,0BAA6B,46EAiE5CD,OAAOC,QAAQ,+BAAkC,eAEjDD,OAAOC,QAAQ,sBAAyB,y1DAyBxCD,OAAOC,QAAQ,yBAA4B,uKAO3CD,OAAOC,QAAQ,0BAA6B,0jRAoQ5CD,OAAOC,QAAQ,+BAAkC,eAEjDD,OAAOC,QAAQ,4BAA+B,4XAc9CD,OAAOC,QAAQ,2BAA8B,8mTAmS7CD,OAAOC,QAAQ,gCAAmC,eAElDD,OAAOC,QAAQ,mCAAsC,ogBAyBrDD,OAAOC,QAAQ,4CAA+C,gGAG9DD,OAAOC,QAAQ,oCAAuC,gGAGtDD,OAAOC,QAAQ,+BAAkC,knUA4ZjDD,OAAOC,QAAQ,8BAAiC,eAEhDD,OAAOC,QAAQ,sCAAyC,ggCAgDxDD,OAAOC,QAAQ,qCAAwC,eAEvDD,OAAOC,QAAQ,gCAAmC,67PAmRlDD,OAAOC,QAAQ,+BAAkC,eAEjDD,OAAOC,QAAQ,mCAAsC,8sHAyGrDD,OAAOC,QAAQ,iCAAoC,++JA0JnDD,OAAOC,QAAQ,+BAAkC,guKA0JjDD,OAAOC,QAAQ,8BAAiC,03GAiHhDD,OAAOC,QAAQ,8BAAiC,spBAWhDD,OAAOC,QAAQ,6BAAgC,y6EA4E/CD,OAAOC,QAAQ,mCAAsC,mwGA0FrDD,OAAOC,QAAQ,kCAAqC,mpZAyYpDD,OAAOC,QAAQ,iCAAoC,ukDAqCnDD,OAAOC,QAAQ,6BAAgC,eAE/CD,OAAOC,QAAQ,6BAAgC,07JAmI/CD,OAAOC,QAAQ,gCAAmC,8oPAgLlDD,OAAOC,QAAQ,qCAAwC,eAEvDD,OAAOC,QAAQ,+BAAkC,41EA4EjDD,OAAOC,QAAQ,oCAAuC,eAEtDD,OAAOC,QAAQ,+BAAkC,+JAKjDD,OAAOC,QAAQ,oCAAuC,+9BAgCtDD,OAAOC,QAAQ,yCAA4C,eAE3DD,OAAOC,QAAQ,0BAA6B,ktCAqC5CD,OAAOC,QAAQ,0BAA6B,wDAG5CD,OAAOC,QAAQ,iCAAoC,szBAsCnDD,OAAOC,QAAQ,2BAA8B,6gCAwB7CD,OAAOC,QAAQ,wBAA2B,wiIAkH1CD,OAAOC,QAAQ,uBAA0B,eAEzCD,OAAOC,QAAQ,wBAA2B,gLAI1CD,OAAOC,QAAQ,qCAAwC,+jBASvDD,OAAOC,QAAQ,6BAAgC,uaAO/CD,OAAOC,QAAQ,qCAAwC,+yCAyCvDD,OAAOC,QAAQ,4CAA+C,q0BA0B9DD,OAAOC,QAAQ,oCAAuC,eAEtDD,OAAOC,QAAQ,kCAAqC,+2UA+PpDD,OAAOC,QAAQ,iCAAoC,ywFAyFnDD,OAAOC,QAAQ,gCAAmC,eAElDD,OAAOC,QAAQ,gCAAmC,gxCAqClDD,OAAOC,QAAQ,+BAAkC,eAEjDD,OAAOC,QAAQ,mCAAsC,8BAErDD,OAAOC,QAAQ,2BAA8B,8BAE7CD,OAAOC,QAAQ,4BAA+B,kxCA2B9CD,OAAOC,QAAQ,0BAA6B,eAE5CD,OAAOC,QAAQ,yBAA4B,svQAwN3CD,OAAOC,QAAQ,wBAA2B,eAE1CD,OAAOC,QAAQ,mCAAsC,2jRA6KrDD,OAAOC,QAAQ,kCAAqC,eAEpDD,OAAOC,QAAQ,0BAA6B,yoKA6I5CD,OAAOC,QAAQ,+BAAkC,+VAQjDD,OAAOC,QAAQ,yBAA4B,eAE3CD,OAAOC,QAAQ,wBAA2B,uwNAsN1CD,OAAOC,QAAQ,6BAAgC,eAE/CD,OAAOC,QAAQ,wBAA2B,u1EAqG1CD,OAAOC,QAAQ,yBAA4B,qJAK3CD,OAAOC,QAAQ,0BAA6B,8yGAuF5CD,OAAOC,QAAQ,+BAAkC,eAEjDD,OAAOC,QAAQ,2BAA8B,42IAmI7CD,OAAOC,QAAQ,gCAAmC,eAElDD,OAAOC,QAAQ,6BAAgC,quBAiC/CD,OAAOC,QAAQ,sCAAyC,2QAKxDD,OAAOC,QAAQ,8BAAiC,2QAKhDD,OAAOC,QAAQ,0BAA6B,q9UAyV5CD,OAAOC,QAAQ,yBAA4B;;ACx1K3CD,OAAOC,QAAP,OAA4B,m4BA+B5BD,OAAOC,QAAP,UAA+B,0nCA+B/BD,OAAOC,QAAP,IAAyB,8oBAoBzBD,OAAOC,QAAP,KAA0B;;AClF1B,IAAIC,EAAY,KAChB,SAASC,IAKAD,OAJFA,IACHA,EAAYE,KAGPF,EAGT,SAASE,IAEH,IACI,MAAA,IAAIC,MACV,MAAOC,GACHC,IAAAA,GAAW,GAAKD,EAAIE,OAAOC,MAAM,iEACjCF,GAAAA,EACKG,OAAAA,EAAWH,EAAQ,IAIvB,MAAA,IAGT,SAASG,EAAWC,GACX,OAAC,GAAKA,GAAKC,QAAQ,wEAAwE,MAAQ,IAG5GX,QAAQG,aAAeD,EACvBF,QAAQS,WAAaA;;AC5BrB,IAAIN,EAAeS,QAAQ,gBAAgBT,aAE3C,SAASU,EAAgBC,GAClBC,MAAMC,QAAQF,KACjBA,EAAU,CAACA,IAGTG,IAAAA,EAAKH,EAAQA,EAAQI,OAAS,GAE9B,IACKC,OAAAA,QAAQC,QAAQR,QAAQK,IAC/B,MAAOZ,GACHA,GAAa,qBAAbA,EAAIgB,KACC,OAAA,IAAIC,EAAY,SAAUF,EAASG,GACxCC,EAAYV,EAAQW,MAAM,GAAI,IAC3BC,KAAK,WACGd,OAAAA,QAAQK,KAEhBS,KAAKN,EAASG,KAIflB,MAAAA,GAIV,SAASmB,EAAYV,GACZK,OAAAA,QAAQQ,IAAIb,EAAQc,IAAIC,IAGjC,IAAIC,EAAgB,GACpB,SAASC,EAAqBC,EAAMC,GAClCH,EAAcE,GAAQC,EAGxBlC,OAAOC,QAAUA,QAAUa,EAC3Bb,QAAQkC,KAAOV,EACfxB,QAAQmC,SAAWJ,EAEnB,IAAIjB,EAAU,GACd,SAASe,EAAWO,GACdnB,IAAAA,EAMAH,GALAC,MAAMC,QAAQoB,KAChBnB,EAAKmB,EAAO,GACZA,EAASA,EAAO,IAGdtB,EAAQsB,GACHtB,OAAAA,EAAQsB,GAGbJ,IAAAA,GAAQI,EAAOC,UAAUD,EAAOE,YAAY,KAAO,EAAGF,EAAOlB,SAAWkB,GAAQG,cAChFC,EAAeV,EAAcE,GAC7BQ,OAAAA,EACK1B,EAAQsB,GAAUI,EAAarC,IAAiBiC,GACpDV,KAAK,SAAUe,GAKPA,OAJHA,GACF1C,OAAOqC,OAAOD,SAASlB,EAAIwB,GAGtBA,IACNC,MAAM,SAASC,GAGVA,aAFC7B,EAAQsB,GAETO,SAXRH,EAgBN,SAASlB,EAAYsB,GACdA,KAAAA,SAAWA,EACXC,KAAAA,QAAU,KAGjBvB,EAAYwB,UAAUpB,KAAO,SAAUqB,EAAWC,GAEzC,OADc,OAAjB,KAAKH,UAAkB,KAAKA,QAAU,IAAI1B,QAAQ,KAAKyB,WACpD,KAAKC,QAAQnB,KAAKqB,EAAWC,IAGtC1B,EAAYwB,UAAUJ,MAAQ,SAAUM,GAE/B,OADc,OAAjB,KAAKH,UAAkB,KAAKA,QAAU,IAAI1B,QAAQ,KAAKyB,WACpD,KAAKC,QAAQH,MAAMM;;AC0B5B,aA3GA,IAAA,aAAA,uBAAA,QAAA,kBACA,WAAA,uBAAA,QAAA,gBA0GA,SAAA,uBAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAxGAC,KAAKC,kBAAoB,CACrBC,aAAc,SAAUC,EAAUC,GAC1BA,MAAU,SAAVA,EACO,mBAEG,SAAVA,EACO,mBAEG,eAAVA,GAAoC,eAAVA,EACnB,iBAEJ,uBAIf,QAAO,iBAAP,CAAO,QAAA,QAAA,kBAAiB3B,KAAM4B,SAE1BA,OAAOC,UAAUC,WAAWC,mBAAmBC,mBAAmB,CAC9DC,OAAQL,OAAOC,UAAUC,WAAWI,aAAaC,OACjDC,sBAAsB,EACtBC,iBAAkBT,OAAOC,UAAUC,WAAWQ,qBAAqBC,OACnElE,OAAQuD,OAAOC,UAAUC,WAAWU,WAAWC,WAG9C,IAAA,MAAMC,KAAOC,OAAOC,KAAKC,aAAZ,SAA0B,CAClCC,MAAAA,0BAAqCJ,IAE3Cd,OAAOC,UAAUC,WAAWC,mBAAmBgB,YAC3CF,aAAYH,QAAAA,GACZI,GAIFE,MAAAA,OAAS,GAGV,IAAA,MAAMN,KAAOC,OAAOC,KAAKK,WAAZ,SACdD,OAAON,GAAOd,OAAOsB,OAAOC,YACxBF,WAAUP,QAAAA,GACV,aACAd,OAAOwB,IAAIC,SAASX,SAItBQ,MAAAA,OAAStB,OAAOsB,OAAOI,OAAOC,SAASC,eAAe,UAAW,CACnEC,MAAOT,OAAOU,OACdC,SAAU,aACVC,MAAO,UACPC,iBAAiB,IASZC,SAAAA,aACE,OAAA,IAAIC,MAAM,OAAW,CACxBC,IAAG,CAAC/B,EAAQS,IACDoB,aAEXG,MAAK,IACMH,aAEXI,UAAS,IACEJ,eAKV5E,SAAAA,QAAQiF,GAENL,OADPM,QAAQC,eAAeF,KAChBL,aAtBXQ,EAAE,gBAAgBC,SAAS,CACvBC,SAAU,SAAUC,EAAKC,EAAGC,GACxBzB,OAAO0B,SAAS5B,OAAO2B,EAAKE,KAAK,cAuBnCC,MAAAA,QAAU,CACZ5F,QAAAA,SAGK6F,SAAAA,YAAYC,IAEV,OAAA,WAAqBC,OAAAA,KAAKD,KAAOE,KAAKJ,SAGjD5B,OAAOiC,WAAWvD,OAAOwD,QAAQC,GAAI,KACjCzD,OAAOC,UAAUC,WAAWwD,sBACvBtF,KAAK,SAAUuF,GACZA,EAAOvC,OAAOU,OAAO8B,KAAKxF,KAAK,SAAUyF,GACrCA,EAAOC,cAAc1C,OAAOU,OAAO8B,IAAIG,YAAY3F,KAAK,SAAU4F,GAG9Db,mEADoEa,EAAEC,YAAY,GAAGC;;AC9F7GzH,OAAOC,QAAU,SAAuBoC,GAC/B,OAAA,IAAIjB,QAAQ,SAAUC,EAASG,GAChCkG,IAAAA,EAAOxC,SAASyC,cAAc,QAClCD,EAAKE,IAAM,aACXF,EAAKG,KAAOxF,EACZqF,EAAKI,QAAU,SAAUlF,GACvB8E,EAAKI,QAAUJ,EAAKK,OAAS,KAC7BvG,EAAOoB,IAGT8E,EAAKK,OAAS,WACZL,EAAKI,QAAUJ,EAAKK,OAAS,KAC7B1G,KAGF6D,SAAS8C,qBAAqB,QAAQ,GAAGC,YAAYP;;ACfzD1H,OAAOC,QAAU,SAAsBoC,GAC9B,OAAA,IAAIjB,QAAQ,SAAUC,EAASG,GAChC0G,IAAAA,EAAShD,SAASyC,cAAc,UACpCO,EAAOC,OAAQ,EACfD,EAAOjG,KAAO,kBACdiG,EAAOE,QAAU,QACjBF,EAAO9B,IAAM/D,EACb6F,EAAOJ,QAAU,SAAUlF,GACzBsF,EAAOJ,QAAUI,EAAOH,OAAS,KACjCvG,EAAOoB,IAGTsF,EAAOH,OAAS,WACdG,EAAOJ,QAAUI,EAAOH,OAAS,KACjC1G,KAGF6D,SAAS8C,qBAAqB,QAAQ,GAAGC,YAAYC","file":"editor.3a13cec4.js","sourceRoot":"../site","sourcesContent":["module.exports['@xmcl/client/channel.d.ts'] = `/// <reference types=\"node\" />\nimport { EventEmitter } from \"events\";\nimport { NetConnectOpts } from \"net\";\nimport { Coder } from \"./coders\";\nimport { PacketRegistryEntry, Side } from \"./packet\";\nexport declare type State = keyof States;\ninterface States {\n    handshake: PacketCoders;\n    login: PacketCoders;\n    status: PacketCoders;\n    play: PacketCoders;\n}\n/**\n * The channel for send and listen the Minecraft packet.\n */\nexport declare class Channel extends EventEmitter {\n    state: State;\n    private readonly states;\n    private connection;\n    private outbound;\n    private inbound;\n    private enableCompression;\n    private compressionThreshold;\n    constructor();\n    /**\n     * Is the connection ready to read and write\n     */\n    get ready(): boolean;\n    findCoderById(packetId: number, side: Side): Coder<any>;\n    getPacketId(packetInst: any, side: Side): number;\n    registerPacketType(clazz: new (...args: any) => any): void;\n    registerPacket(entry: PacketRegistryEntry): void;\n    /**\n     * Open the connection and start to listen the port.\n     */\n    listen(option: NetConnectOpts & {\n        keepalive?: boolean | number;\n    }): Promise<void>;\n    disconnect(): Promise<void>;\n    /**\n     * Sent a packet to server.\n     */\n    send<T>(message: T, skeleton?: Partial<T>): void;\n    /**\n     * Listen for sepcific packet by its class name.\n     */\n    onPacket<T>(packet: new (...args: any[]) => T, listener: (event: T) => void): this;\n    oncePacket<T>(packet: new (...args: any[]) => T, listener: (event: T) => void): this;\n}\nexport interface Channel extends EventEmitter {\n    on<T>(channel: string, listener: (event: T) => void): this;\n    once<T>(channel: string, listener: (event: T) => void): this;\n}\ndeclare class PacketCoders {\n    packetIdCoders: {\n        [packetId: number]: Coder<any>;\n    };\n    packetNameToId: {\n        [name: string]: number;\n    };\n}\nexport {};\n`;\nmodule.exports['@xmcl/client/coders.d.ts'] = `/// <reference types=\"long\" />\nimport ByteBuffer from \"bytebuffer\";\nexport interface SlotData {\n    blockId: number;\n    itemCount?: number;\n    itemDamage?: number;\n    nbt?: any;\n}\n/**\n * The packet encode/decode algorithm\n */\nexport interface Coder<T> {\n    readonly encode: (buffer: ByteBuffer, data: T, context?: any) => void;\n    readonly decode: (buffer: ByteBuffer, context?: any) => T;\n}\nexport declare const VarInt: Coder<number>;\nexport declare const Int: Coder<number>;\nexport declare const Byte: Coder<number>;\nexport declare const UByte: Coder<number>;\nexport declare const Bool: Coder<boolean>;\nexport declare const Float: Coder<number>;\nexport declare const Double: Coder<number>;\nexport declare const UUID: Coder<string>;\nexport declare const Short: Coder<number>;\nexport declare const UShort: Coder<number>;\nexport declare const Long: Coder<Long>;\nexport declare const VarLong: Coder<Long>;\nexport declare const String: Coder<string>;\nexport declare const Json: Coder<any>;\nexport declare const Slot: Coder<SlotData>;\nexport declare const ByteArray: Coder<Int8Array>;\n`;\nmodule.exports['@xmcl/client/coders.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/client/index.d.ts'] = `export * from \"./coders\";\nexport * from \"./packet\";\nexport * from \"./channel\";\nexport * from \"./status\";\n`;\nmodule.exports['@xmcl/client/packet.d.ts'] = `import { State } from \"./channel\";\nimport { Coder } from \"./coders\";\nexport declare type Side = \"server\" | \"client\";\nexport interface PacketRegistryEntry {\n    readonly id: number;\n    readonly name: string;\n    readonly state: State;\n    readonly side: Side;\n    readonly coder: Coder<any>;\n}\nexport declare type FieldType<T> = (type: Coder<T>) => (target: any, key: string) => void;\nexport declare type PacketType = (side: Side, id: number, state: State) => (constructor: Function) => void;\nexport declare const PacketMetadata: unique symbol;\nexport declare const PacketFieldsMetadata: unique symbol;\n/**\n * Get a packet registry entry for a class\n * @param clazz The class object\n */\nexport declare function getPacketRegistryEntry(clazz: new (...args: any) => any): PacketRegistryEntry;\n/**\n * Annotate the field type in your packet. Assign a coder for serialization/deserialization.\n * This will generate a list of \\`FieldType\\` in your class prototype.\n *\n * @param type The coder to serialize/deserialize the field.\n * @see \"coders.ts\"\n */\nexport declare function Field<T>(type: Coder<T>): (target: any, key: string) => void;\n/**\n * Decoarte for you packet class.\n * This will generate a \\`PacketRegistryEntry\\` in your class prototype.\n *\n * @param side The side of your packet\n * @param id The id of your packet\n * @param state The state of you packet should be\n */\nexport declare function Packet(side: Side, id: number, state: State, name?: string): (constructor: Function) => void;\n`;\nmodule.exports['@xmcl/client/status.d.ts'] = `import { TextComponent } from \"@xmcl/text-component\";\nimport Long from \"long\";\nimport { Channel } from \"./channel\";\nexport declare class Handshake {\n    protocolVersion: number;\n    serverAddress: string;\n    serverPort: number;\n    nextState: number;\n}\nexport declare class ServerQuery {\n}\nexport declare class ServerStatus {\n    status: Status;\n}\nexport declare class Ping {\n    time: Long.Long;\n}\nexport declare class Pong {\n    ping: Long;\n}\n/**\n * The json format for Minecraft server handshake status query response\n */\nexport interface Status {\n    /**\n     * The version info of the server\n     */\n    version: {\n        /**\n         * The name of the version, might be standard version, like 1.14.4.\n         * Or it can be modified content, just be any string the server hoster like.\n         */\n        name: string;\n        /**\n         * The protocol version\n         */\n        protocol: number;\n    };\n    /**\n     * The player info in server\n     */\n    players: {\n        /**\n         * The server max player capacity\n         */\n        max: number;\n        /**\n         * The current online player number\n         */\n        online: number;\n        /**\n         * The online player info\n         */\n        sample?: Array<GameProfile>;\n    };\n    /**\n     * The motd of server, which might be the raw TextComponent string or structurelized TextComponent JSON\n     */\n    description: TextComponent | string;\n    /**\n     * The base 64 favicon data\n     */\n    favicon: string | \"\";\n    modinfo?: {\n        type: string | \"FML\";\n        modList: Array<ForgeModIdentity>;\n    };\n    /**\n     * The ping from server\n     */\n    ping: number;\n}\ninterface GameProfile {\n    name: string;\n    id: string;\n}\ninterface ForgeModIdentity {\n    readonly modid: string;\n    readonly version: string;\n}\nexport interface QueryOptions {\n    /**\n     * see http://wiki.vg/Protocol_version_numbers\n     */\n    protocol?: number;\n    /**\n     * timeout milliseconds\n     */\n    timeout?: number;\n    retryTimes?: number;\n}\n/**\n * Create a channel with Handleshake, ServerQuery, ServerStatus, Ping, Pong packets are registered.\n *\n * This is a lower level function for the case that you want to use channel directly\n *\n * @see Channel\n */\nexport declare function createChannel(): Channel;\n/**\n * Query the server status in raw JSON format in one shot.\n *\n * @param server The server information\n * @param options The query options\n */\nexport declare function queryStatus(server: {\n    host: string;\n    port?: number;\n}, options?: QueryOptions): Promise<Status>;\n/**\n * Create a query client for certain protocol and timeout setting.\n * @param protocol The protocol number\n * @param timeout The timeout millisecond\n */\nexport declare function createClient(protocol: number, timeout?: number): {\n    readonly channel: Channel;\n    protocol: number;\n    query(host: string, port?: number): Promise<Status>;\n};\nexport {};\n`;\nmodule.exports['@xmcl/client/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/core/folder.d.ts'] = `export interface MinecraftFolder {\n    readonly root: string;\n}\nexport declare class MinecraftFolder {\n    readonly root: string;\n    /**\n     * Normal a Minecraft folder from a folder or string\n     */\n    static from(location: MinecraftLocation): MinecraftFolder;\n    constructor(root: string);\n    get mods(): string;\n    get resourcepacks(): string;\n    get assets(): string;\n    get libraries(): string;\n    get versions(): string;\n    get logs(): string;\n    get options(): string;\n    get launcherProfile(): string;\n    get lastestLog(): string;\n    get maps(): string;\n    get saves(): string;\n    get screenshots(): string;\n    getNativesRoot(version: string): string;\n    getVersionRoot(version: string): string;\n    getVersionJson(version: string): string;\n    getVersionJar(version: string, type?: string): string;\n    getVersionAll(version: string): string[];\n    getResourcePack(fileName: string): string;\n    getMod(fileName: string): string;\n    getLog(fileName: string): string;\n    getMapInfo(map: string): string;\n    getMapIcon(map: string): string;\n    getLibraryByPath(libraryPath: string): string;\n    getAssetsIndex(versionAssets: string): string;\n    getAsset(hash: string): string;\n    getPath(...path: string[]): string;\n}\nexport declare namespace MinecraftPath {\n    const mods = \"mods\";\n    const resourcepacks = \"resourcepacks\";\n    const assets = \"assets\";\n    const libraries = \"libraries\";\n    const versions = \"versions\";\n    const logs = \"logs\";\n    const options = \"options.txt\";\n    const launcherProfile = \"launcher_profiles.json\";\n    const lastestLog = \"logs/latest.log\";\n    const maps = \"saves\";\n    const saves = \"saves\";\n    const screenshots = \"screenshots\";\n    function getVersionRoot(version: string): string;\n    function getNativesRoot(version: string): string;\n    function getVersionJson(version: string): string;\n    function getVersionJar(version: string, type?: string): string;\n    function getResourcePack(fileName: string): string;\n    function getMod(fileName: string): string;\n    function getLog(fileName: string): string;\n    function getMapInfo(map: string): string;\n    function getMapIcon(map: string): string;\n    function getLibraryByPath(libraryPath: string): string;\n    function getAssetsIndex(versionAssets: string): string;\n    function getAsset(hash: string): string;\n}\nexport declare type MinecraftLocation = MinecraftFolder | string;\n`;\nmodule.exports['@xmcl/core/folder.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/core/fs.d.ts'] = `/// <reference types=\"node\" />\nimport { readFile as freadFile, readdir as freaddir, rename as frename, readlink as freadlink, stat as fstat, copyFile as fcopyFile, unlink as funlink, writeFile as fwriteFile, access as faccess, mkdir as fmkdir, rmdir as frmdir } from \"fs\";\nexport declare const readFile: typeof freadFile.__promisify__;\nexport declare const writeFile: typeof fwriteFile.__promisify__;\nexport declare const stat: typeof fstat.__promisify__;\nexport declare const readlink: typeof freadlink.__promisify__;\nexport declare const copyFile: typeof fcopyFile.__promisify__;\nexport declare const unlink: typeof funlink.__promisify__;\nexport declare const rename: typeof frename.__promisify__;\nexport declare const readdir: typeof freaddir.__promisify__;\nexport declare const access: typeof faccess.__promisify__;\nexport declare const mkdir: typeof fmkdir.__promisify__;\nexport declare const rmdir: typeof frmdir.__promisify__;\nexport declare function waitStream(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream): Promise<void>;\nexport declare function exists(target: string): Promise<boolean>;\nexport declare function missing(target: string): Promise<boolean>;\nexport declare function validateSha1(target: string, hash?: string): Promise<boolean>;\nexport declare function validateMd5(target: string, hash?: string): Promise<boolean>;\nexport declare function copyPassively(src: string, dest: string, filter?: (name: string) => boolean): Promise<void>;\nexport declare function ensureDir(target: string): Promise<void>;\nexport declare function ensureFile(target: string): Promise<void>;\nexport declare function remove(f: string): Promise<void>;\nexport declare function checksum(path: string, algorithm?: string): Promise<string>;\nexport declare function checksums(path: string, algorithms: string[]): Promise<string[]>;\n`;\nmodule.exports['@xmcl/core/index.d.ts'] = `export * from \"./launch\";\nexport * from \"./version\";\nexport * from \"./platform\";\nexport * from \"./folder\";\nimport * as futils from \"./fs\";\nexport { futils };\n`;\nmodule.exports['@xmcl/core/launch.d.ts'] = `/// <reference types=\"node\" />\nimport { ChildProcess, SpawnOptions } from \"child_process\";\nimport { MinecraftFolder } from \"./folder\";\nimport { ResolvedVersion } from \"./version\";\nimport { EventEmitter } from \"events\";\nexport declare const DEFAULT_EXTRA_JVM_ARGS: readonly string[];\nexport interface EnabledFeatures {\n    [featureName: string]: object | boolean | undefined;\n    has_custom_resolution?: {\n        resolution_width: string;\n        resolution_height: string;\n    };\n    is_demo_user?: boolean;\n}\n/**\n * General launch option, used to generate launch arguments.\n */\nexport interface LaunchOption {\n    /**\n     * User selected game profile. For game display name &\n     */\n    gameProfile?: {\n        name: string;\n        id: string;\n    };\n    accessToken?: string;\n    userType?: \"mojang\" | \"legacy\";\n    properties?: object;\n    launcherName?: string;\n    launcherBrand?: string;\n    /**\n     * Overwrite the version name of the current version.\n     * If this is absent, it will use version name from resolved version.\n     */\n    versionName?: string;\n    /**\n     * Overwrite the version type of the current version.\n     * If this is absent, it will use version type from resolved version.\n     *\n     * Some people use this to show fantastic message on the welcome screen.\n     */\n    versionType?: string;\n    /**\n     * The full path of launched game icon\n     * Currently, this only supported on MacOS\n     */\n    gameIcon?: string;\n    /**\n     * The launched game name\n     * Currently, this only supported on MacOS\n     */\n    gameName?: string;\n    /**\n     * The path of parent directory of saves/logs/configs/mods/resourcepacks\n     */\n    gamePath: string;\n    /**\n     * The path of parent directory of assets/libraries\n     */\n    resourcePath?: string;\n    /**\n     * The java executable file path. (Not the java home direcotry!)\n     */\n    javaPath: string;\n    /**\n     * Min memory, this will add a jvm flag -Xms to the command result\n     */\n    minMemory?: number;\n    /**\n     * Min memory, this will add a jvm flag -Xmx to the command result\n     */\n    maxMemory?: number;\n    /**\n     * The version of launched Minecraft. Can be either resolved version or version string\n     */\n    version: string | ResolvedVersion;\n    /**\n     * Directly launch to a server\n     */\n    server?: {\n        ip: string;\n        port?: number;\n    };\n    /**\n     * Resolution. This will add --height & --width or --fullscreen to the java arguments\n     */\n    resolution?: {\n        width?: number;\n        height?: number;\n        fullscreen?: true;\n    };\n    /**\n     * Extra jvm options. This will append after to generated options.\n     * If this is empty, the \\`DEFAULT_EXTRA_JVM_ARGS\\` will be used.\n     */\n    extraJVMArgs?: string[];\n    /**\n     * Extra program arguments. This will append after to generated options.\n     */\n    extraMCArgs?: string[];\n    /**\n     * Assign the spawn options to the process.\n     *\n     * If you try to set \\`{ shell: true }\\`, you might want to make all argument rounded with \"\".\n     * The \\`launch\\` function will do it for you, but if you want to spawn process by yourself, remember to do that.\n     */\n    extraExecOption?: SpawnOptions;\n    isDemo?: boolean;\n    /**\n     * Native directory. It's .minecraft/versions/<version>/<version>-natives by default.\n     * You can replace this by your self.\n     */\n    nativeRoot?: string;\n    /**\n     * Enable features. Not really in used...\n     */\n    features?: EnabledFeatures;\n    /**\n     * Support yushi's yggdrasil agent https://github.com/to2mbn/authlib-injector/wiki\n     */\n    yggdrasilAgent?: {\n        /**\n         * The jar file path of the authlib-injector\n         */\n        jar: string;\n        /**\n         * The auth server host\n         */\n        server: string;\n        /**\n         * The prefetched base64\n         */\n        prefetched?: string;\n    };\n    /**\n     * Add \\`-Dfml.ignoreInvalidMinecraftCertificates=true\\` to jvm argument\n     */\n    ignoreInvalidMinecraftCertificates?: boolean;\n    /**\n     * Add \\`-Dfml.ignorePatchDiscrepancies=true\\` to jvm argument\n     */\n    ignorePatchDiscrepancies?: boolean;\n}\nexport interface LaunchPrecheck {\n    (resourcePath: MinecraftFolder, version: ResolvedVersion, option: LaunchOption): Promise<void>;\n}\nexport declare namespace LaunchPrecheck {\n    const Default: LaunchPrecheck[];\n    /**\n     * Quick check if Minecraft version jar is corrupted\n     */\n    function checkVersion(resource: MinecraftFolder, version: ResolvedVersion, option: LaunchOption): Promise<void>;\n    /**\n     * Quick check if there are missed libraries.\n     */\n    function checkLibraries(resource: MinecraftFolder, version: ResolvedVersion, option: LaunchOption): Promise<void>;\n    /**\n     * Ensure the native are correctly extracted there.\n     * @param native The native directory path\n     */\n    function checkNatives(resource: MinecraftFolder, version: ResolvedVersion, option: LaunchOption): Promise<void>;\n}\nexport interface ServerOptions {\n    javaPath: string;\n    /**\n     * Minecraft location\n     */\n    path: string;\n    /**\n     * Current working directory. Default is the same with the path.\n     */\n    cwd?: string;\n    version: string | ResolvedVersion;\n    nogui?: boolean;\n    minMemory?: number;\n    maxMemory?: number;\n    extraJVMArgs?: string[];\n    extraMCArgs?: string[];\n    extraExecOption?: SpawnOptions;\n}\nexport declare function launchServer(options: ServerOptions): Promise<ChildProcess>;\n/**\n * The Minecraft process watcher. You can inspect Minecraft launch state by this.\n *\n * Generally, there are several cases after you call \\`launch\\` and get \\`ChildProcess\\` object\n *\n * 1. child process fire an error, no real process start.\n *\n */\nexport interface MinecraftProcessWatcher extends EventEmitter {\n    /**\n     * Fire when the process DOESN'T start at all, like \"java not found\".\n     *\n     * The minecraft-kill or minecraft-exit will NOT fire after this fired.\n     */\n    on(event: \"error\", listener: (error: any) => void): this;\n    /**\n     * Fire after Minecraft process exit.\n     */\n    on(event: \"minecraft-exit\", listener: (event: {\n        /**\n         * The code of the process exit. This is the nodejs child process \"exit\" event arg.\n         */\n        code: number;\n        /**\n         * The signal of the process exit. This is the nodejs child process \"exit\" event arg.\n         */\n        signal: string;\n        /**\n         * The crash report content\n         */\n        crashReport: string;\n        /**\n         * The location of the crash report\n         */\n        crashReportLocation: string;\n    }) => void): this;\n    /**\n     * Fire around the time when Minecraft window appeared in screen.\n     *\n     * Since the Minecraft window will take time to init, this event fire when it capture some keywords from stdout.\n     */\n    on(event: \"minecraft-window-ready\", listener: () => void): this;\n}\n/**\n * Create a process watcher for a minecraft process.\n *\n * It will watch the stdout and the error event of the process to detect error and minecraft state.\n * @param process The Minecraft process\n * @param emitter The event emitter which will emit usefule event\n */\nexport declare function createMinecraftProcessWatcher(process: ChildProcess, emitter?: EventEmitter): MinecraftProcessWatcher;\n/**\n * Launch the minecraft as a child process. This function use spawn to create child process. To use an alternative way, see function generateArguments.\n *\n * This function will also check if the runtime libs are completed, and will extract native libs if needed.\n * This function might throw exception when the version jar is missing/checksum not matched.\n * This function might throw if the libraries/natives are missing.\n *\n * @param options The detail options for this launching.\n * @see ChildProcess\n * @see spawn\n * @see generateArguments\n * @see createMinecraftProcessWatcher\n */\nexport declare function launch(options: LaunchOption & {\n    prechecks?: LaunchPrecheck[];\n}): Promise<ChildProcess>;\n/**\n * Generate the argument for server\n */\nexport declare function generateArgumentsServer(options: ServerOptions): Promise<string[]>;\n/**\n * Generate the arguments array by options. This function is useful if you want to launch the process by yourself.\n *\n * This function will NOT check if the runtime libs are completed, and WONT'T check or extract native libs.\n *\n */\nexport declare function generateArguments(options: LaunchOption): Promise<string[]>;\n`;\nmodule.exports['@xmcl/core/launch.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/core/platform.d.ts'] = `export interface Platform {\n    name: \"osx\" | \"linux\" | \"windows\" | \"unknown\";\n    version: string;\n    arch: \"x86\" | \"x64\" | string;\n}\n/**\n * Get Minecraft style platform info. (Majorly used to enable/disable native dependencies)\n */\nexport declare function getPlatform(): Platform;\n/**\n * The current platform\n */\nexport declare const currentPlatform: Platform;\n`;\nmodule.exports['@xmcl/core/version.d.ts'] = `import { MinecraftLocation } from \"./folder\";\nimport { Platform } from \"./platform\";\nexport interface PartialResolvedVersion extends Version {\n    libraries: ResolvedLibrary[];\n    arguments: {\n        game: Version.LaunchArgument[];\n        jvm: Version.LaunchArgument[];\n    };\n    minecraftDirectory: string;\n}\n/**\n * The resolved version for launcher.\n * It could be a combination of multiple versions as there might be some inheritions.\n */\nexport interface ResolvedVersion {\n    /**\n     * The id of the version, should be identical to the version folder.\n     */\n    id: string;\n    arguments: {\n        game: Version.LaunchArgument[];\n        jvm: Version.LaunchArgument[];\n    };\n    /**\n     * The main class full qualified name\n     */\n    mainClass: string;\n    assetIndex: Version.AssetIndex;\n    /**\n     * The asset index id of this version. Should be something like \\`1.14\\`, \\`1.12\\`\n     */\n    assets: string;\n    downloads: {\n        client: Version.Download;\n        server: Version.Download;\n        [key: string]: Version.Download;\n    };\n    libraries: ResolvedLibrary[];\n    minimumLauncherVersion: number;\n    releaseTime: string;\n    time: string;\n    type: string;\n    logging?: {\n        [key: string]: {\n            file: Version.Download;\n            argument: string;\n            type: string;\n        };\n    };\n    /**\n     * The minecraft version of this version\n     */\n    minecraftVersion: string;\n    /**\n     * The minecraft directory of this version\n     */\n    minecraftDirectory: string;\n    /**\n     * The version inheritances of this whole resolved version.\n     *\n     * The first element is this version, and the last element is the root Minecraft version.\n     * The dependencies of [<a>, <b>, <c>] should be <a> -> <b> -> <c>, where c is a Minecraft version.\n     */\n    inheritances: string[];\n    /**\n     * All array of json file paths.\n     *\n     * It's the chain of inherits json path. The root json will be the last element of the array.\n     * The first element is the user provided version.\n     */\n    pathChain: string[];\n}\nexport interface LibraryInfo {\n    readonly groupId: string;\n    readonly artifactId: string;\n    readonly version: string;\n    readonly isSnapshot: boolean;\n    readonly type: string;\n    readonly classifier: string;\n    readonly path: string;\n    readonly name: string;\n}\nexport declare namespace LibraryInfo {\n    function resolveFromPath(path: string): LibraryInfo;\n    /**\n     * Get the base info of the library from its name\n     *\n     * @param lib The name of library or the library itself\n     */\n    function resolve(lib: string | Version.Library | ResolvedLibrary): LibraryInfo;\n}\n/**\n * A resolved library for launcher. It can by parsed from \\`LibraryInfo\\`.\n */\nexport declare class ResolvedLibrary implements LibraryInfo {\n    readonly name: string;\n    readonly download: Version.Artifact;\n    readonly checksums?: string[] | undefined;\n    readonly serverreq?: boolean | undefined;\n    readonly clientreq?: boolean | undefined;\n    readonly groupId: string;\n    readonly artifactId: string;\n    readonly version: string;\n    readonly isSnapshot: boolean;\n    readonly type: string;\n    readonly classifier: string;\n    readonly path: string;\n    constructor(name: string, info: LibraryInfo, download: Version.Artifact, checksums?: string[] | undefined, serverreq?: boolean | undefined, clientreq?: boolean | undefined);\n}\n/**\n * Represent a native libraries provided by Minecraft\n */\nexport declare class ResolvedNative extends ResolvedLibrary {\n    readonly extractExclude?: string[] | undefined;\n    constructor(name: string, info: LibraryInfo, download: Version.Artifact, extractExclude?: string[] | undefined);\n}\nexport declare namespace Version {\n    interface Download {\n        readonly sha1: string;\n        readonly size: number;\n        url: string;\n    }\n    interface AssetIndex extends Download {\n        readonly id: string;\n        readonly totalSize: number;\n    }\n    interface Artifact extends Download {\n        readonly path: string;\n    }\n    interface LoggingFile extends Download {\n        readonly id: string;\n    }\n    interface NormalLibrary {\n        name: string;\n        downloads: {\n            artifact: Artifact;\n        };\n    }\n    interface Rule {\n        action: \"allow\" | \"disallow\";\n        os?: Partial<Platform>;\n        features?: {\n            [feat: string]: boolean;\n        };\n    }\n    interface NativeLibrary {\n        name: string;\n        downloads: {\n            artifact: Artifact;\n            classifiers: {\n                [os: string]: Artifact;\n            };\n        };\n        rules: Rule[];\n        extract: {\n            exclude: string[];\n        };\n        natives: {\n            [os: string]: string;\n        };\n    }\n    interface PlatformSpecificLibrary {\n        name: string;\n        downloads: {\n            artifact: Artifact;\n        };\n        rules: Rule[];\n    }\n    interface LegacyLibrary {\n        name: string;\n        url?: string;\n        clientreq?: boolean;\n        serverreq?: boolean;\n        checksums?: string[];\n    }\n    type Library = NormalLibrary | NativeLibrary | PlatformSpecificLibrary | LegacyLibrary;\n    type LaunchArgument = string | {\n        rules: Rule[];\n        value: string | string[];\n    };\n    /**\n      * Check if all the rules in \\`Rule[]\\` are acceptable in certain OS \\`platform\\` and features.\n      * @param rules The rules usually comes from \\`Library\\` or \\`LaunchArgument\\`\n      * @param platform The platform, leave it absent will use the \\`currentPlatform\\`\n      * @param features The features, used by game launch argument \\`arguments.game\\`\n      */\n    function checkAllowed(rules: Rule[], platform?: Platform, features?: string[]): boolean;\n    /**\n     * Recursively parse the version JSON.\n     *\n     * This function requires that the id in version.json is identical to the directory name of that version.\n     *\n     * e.g. .minecraft/<version-a>/<version-a.json> and in <version-a.json>:\n     *\n     * { \"id\": \"<version-a>\", ... }\n     *\n     * @param minecraftPath The .minecraft path\n     * @param version The vesion id.\n     * @return The final resolved version detail\n     */\n    function parse(minecraftPath: MinecraftLocation, version: string): Promise<ResolvedVersion>;\n    /**\n     * Simply extends the version (actaully mixin)\n     *\n     * The result version will have the union of two version's libs. If one lib in two versions has different version, it will take the extra version one.\n     * It will also mixin the launchArgument if it could.\n     *\n     * This function can be used for mixin forge and liteloader version.\n     *\n     * This function will throw an Error if two version have different assets. It doesn't care about the detail version though.\n     *\n     * @beta\n     * @param id The new version id\n     * @param parent The parent version will be inherited\n     * @param version The version info which will overlap some parent information\n     * @return The raw version json could be save to the version json file\n     */\n    function inherits(id: string, parent: Version, version: Version): Version;\n    /**\n     * Mixin the string arguments\n     * @beta\n     * @param hi Higher priority argument\n     * @param lo Lower priority argument\n     */\n    function mixinArgumentString(hi: string, lo: string): string;\n    /**\n     * Resolve the dependencies of a minecraft version\n     * @param path The path of minecraft\n     * @param version The version id\n     * @returns All the version required to run this version, including this version\n     */\n    function resolveDependency(path: MinecraftLocation, version: string): Promise<PartialResolvedVersion[]>;\n    function resolveLibrary(lib: Library, platform?: Platform): ResolvedLibrary | undefined;\n    /**\n     * Resolve all these library and filter out os specific libs\n     * @param libs All raw lib\n     * @param platform The platform\n     */\n    function resolveLibraries(libs: Library[], platform?: Platform): ResolvedLibrary[];\n    /**\n     * Normalize a single version json.\n     *\n     * This function will force legacy version format into new format.\n     * It will convert \\`minecraftArguments\\` into \\`arguments.game\\` and generate a default \\`arguments.jvm\\`\n     *\n     * This will pre-process the libraries according to the rules fields and current platform.\n     * Non-matched libraries will be filtered out.\n     *\n     * This will also pre-process the jvm arguments according to the platform (os) info it provided.\n     *\n     * @param versionString The version json string\n     * @param root The root of the version\n     */\n    function normalizeVersionJson(versionString: string, root: string): PartialResolvedVersion;\n}\n/**\n * The raw json format provided by Minecraft\n */\nexport interface Version {\n    id: string;\n    time: string;\n    type: string;\n    releaseTime: string;\n    inheritsFrom?: string;\n    minimumLauncherVersion: number;\n    minecraftArguments?: string;\n    arguments?: {\n        game: Version.LaunchArgument[];\n        jvm: Version.LaunchArgument[];\n    };\n    mainClass: string;\n    libraries: Version.Library[];\n    jar?: string;\n    assetIndex?: Version.AssetIndex;\n    assets?: string;\n    downloads?: {\n        client: Version.Download;\n        server: Version.Download;\n        [key: string]: Version.Download;\n    };\n    client?: string;\n    server?: string;\n    logging?: {\n        [key: string]: {\n            file: Version.Download;\n            argument: string;\n            type: string;\n        };\n    };\n}\n`;\nmodule.exports['@xmcl/core/version.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/curseforge/http/base.d.ts'] = `/// <reference types=\"node\" />\nimport { Agent } from \"https\";\n/**\n * Abstract layer for http requester.\n */\nexport declare type HttpRequester = (option: {\n    url: string;\n    method: string;\n    headers: {\n        [key: string]: string;\n    };\n    /**\n     * Search string\n     */\n    search?: {\n        [key: string]: string | string[] | undefined;\n    };\n    body?: object;\n    userAgent?: Agent;\n}) => Promise<{\n    body: string;\n    statusMessage: string;\n    statusCode: number;\n}>;\n`;\nmodule.exports['@xmcl/curseforge/http/index.browser.d.ts'] = `import { HttpRequester } from \"./base\";\nexport declare const httpRequester: HttpRequester;\n`;\nmodule.exports['@xmcl/curseforge/http/index.d.ts'] = `import { HttpRequester } from \"./base\";\nexport declare const httpRequester: HttpRequester;\n`;\nmodule.exports['@xmcl/curseforge/index.d.ts'] = `/// <reference types=\"node\" />\nimport { Agent } from \"https\";\nexport interface AddonInfo {\n    /**\n     * The addon id. You can use this in many functions required the \\`addonID\\`\n     */\n    id: number;\n    /**\n     * The display name of the addon\n     */\n    name: string;\n    /**\n     * The list of authors\n     */\n    authors: Author[];\n    /**\n     * The attachments. Usually include the project icon and the exmaple images.\n     */\n    attachments: Attachment[];\n    websiteUrl: string;\n    /**\n     * Game id. Minecraft is 432.\n     */\n    gameId: number;\n    /**\n     * One line summery\n     */\n    summary: string;\n    /**\n     * The default download file id\n     */\n    defaultFileId: number;\n    downloadCount: number;\n    latestFiles: File[];\n    /**\n     * The category of the project\n     */\n    categories: ProjectCategory[];\n    status: number;\n    primaryCategoryId: number;\n    /**\n     * The big category section\n     */\n    categorySection: CategorySection;\n    slug: string;\n    gameVersionLatestFiles: GameVersionLatestFile[];\n    isFeatured: boolean;\n    popularityScore: number;\n    gamePopularityRank: number;\n    primaryLanguage: string;\n    gameSlug: string;\n    gameName: string;\n    portalName: string;\n    dateModified: string;\n    dateCreated: string;\n    dateReleased: string;\n    isAvailable: boolean;\n    isExperiemental: boolean;\n}\nexport interface GameVersionLatestFile {\n    gameVersion: string;\n    projectFileId: number;\n    projectFileName: string;\n    fileType: number;\n}\nexport interface CategorySection {\n    id: number;\n    gameId: number;\n    name: string;\n    packageType: number;\n    path: string;\n    initialInclusionPattern: string;\n    extraIncludePattern?: any;\n    gameCategoryId: number;\n}\nexport interface File {\n    /**\n     * The fileID\n     */\n    id: number;\n    /**\n     * Display name\n     */\n    displayName: string;\n    /**\n     * File name. Might be the same with \\`displayName\\`\n     */\n    fileName: string;\n    /**\n     * The date of this file uploaded\n     */\n    fileDate: string;\n    /**\n     * # bytes of this file.\n     */\n    fileLength: number;\n    /**\n     * Release or type.\n     * - \\`1\\` is the release\n     * - \\`\\`\n     */\n    releaseType: number;\n    fileStatus: number;\n    /**\n     * Url to download\n     */\n    downloadUrl: string;\n    isAlternate: boolean;\n    alternateFileId: number;\n    dependencies: any[];\n    isAvailable: boolean;\n    /**\n     * What files inside?\n     */\n    modules: Module[];\n    packageFingerprint: number;\n    /**\n     * Game version string array, like \\`[\"1.12.2\"]\\`\n     */\n    gameVersion: string[];\n    sortableGameVersion?: SortableGameVersion[];\n    installMetadata?: any;\n    changelog?: any;\n    hasInstallScript: boolean;\n    isCompatibleWithClient: boolean;\n    categorySectionPackageType: number;\n    restrictProjectFileAccess: number;\n    projectStatus: number;\n    renderCacheId: number;\n    fileLegacyMappingId?: any;\n    /**\n     * The projectId (addonId)\n     */\n    projectId: number;\n    parentProjectFileId?: any;\n    parentFileLegacyMappingId?: any;\n    fileTypeId?: any;\n    exposeAsAlternative?: any;\n    packageFingerprintId: number;\n    gameVersionDateReleased: string;\n    gameVersionMappingId: number;\n    /**\n     * A number represents the game version id from curseforge (Not the same with Minecraft version string id).\n     */\n    gameVersionId: number;\n    gameId: number;\n    isServerPack: boolean;\n    serverPackFileId?: any;\n}\nexport interface SortableGameVersion {\n    gameVersionPadded: string;\n    gameVersion: string;\n    gameVersionReleaseDate: string;\n    gameVersionName: string;\n}\n/**\n * Represent a file in a \\`File\\`.\n */\nexport interface Module {\n    /**\n     * Actually the file name, not the folder\n     */\n    foldername: string;\n    /**\n     * A number represent fingerprint\n     */\n    fingerprint: number;\n    type: number;\n}\nexport interface Attachment {\n    id: number;\n    projectId: number;\n    description: string;\n    isDefault: boolean;\n    /**\n     * Small icon\n     */\n    thumbnailUrl: string;\n    /**\n     * The title of this attachment\n     */\n    title: string;\n    /**\n     * The url. Usually the image url.\n     */\n    url: string;\n    status: number;\n}\n/**\n * The author info\n */\nexport interface Author {\n    /**\n     * The project id of this query\n     */\n    projectId: number;\n    projectTitleId?: any;\n    projectTitleTitle?: any;\n    /**\n     * Display name of the author\n     */\n    name: string;\n    /**\n     * The full url of author homepage in curseforge\n     */\n    url: string;\n    /**\n     * The id of this author\n     */\n    id: number;\n    userId: number;\n    twitchId: number;\n}\nexport interface ProjectCategory {\n    categoryId: number;\n    name: string;\n    url: string;\n    avatarUrl: string;\n    parentId: number;\n    rootId: number;\n    projectId: number;\n    avatarId: number;\n    gameId: number;\n}\n/**\n * The category in curseforge. For example, \"World\", \"Resource Packs\", \"Modpacks\", \"Mods\"... and so on..\n */\nexport interface Category {\n    /**\n     * The number id of the category. e.g. \\`4471\\`\n     */\n    id: number;\n    /**\n     * The display name of the category. For example, \"Resource Packs\", \"Modpacks\", \"Mods\"...\n     */\n    name: string;\n    /**\n     * The slug is used on url path. It should looks like, \"modpacks\", \"texture-packs\", \"mc-mods\"...\n     */\n    slug: string;\n    /**\n     * The display icon of the category\n     */\n    avatarUrl: string;\n    /**\n     * Last modified date. The string of \\`Date\\`.\n     */\n    dateModified: string;\n    /**\n     * The parent category id (\\`Category.id\\`)\n     */\n    parentGameCategoryId: number;\n    /**\n     * The root category id.\n     */\n    rootGameCategoryId: number;\n    /**\n     * The game id. Minecraft is 432.\n     */\n    gameId: number;\n}\nexport interface SearchOptions {\n    /**\n     * Please use \\`getCategories\\` to find the category id\n     */\n    categoryID?: number;\n    sectionId?: number | MinecraftSection;\n    /**\n     * The game id. The Minecraft is 432.\n     * @default 432\n     */\n    gameId?: number;\n    /**\n     * The game version. For Minecraft, it should looks lile 1.12.2\n     */\n    gameVersion?: string;\n    /**\n     * @default 0\n     */\n    index?: number;\n    /**\n     * @default 25\n     */\n    pageSize?: number;\n    /**\n     * The keyword of search\n     */\n    searchFilter: string;\n    /**\n     * @default 0\n     */\n    sort?: number;\n}\nexport interface GetFeaturedAddonOptions {\n    /**\n     * The game id. The Minecraft is 432.\n     * @default 432\n     */\n    gameId?: number;\n    /**\n     * The # of featured\n     */\n    featuredCount?: number;\n    popularCount?: number;\n    updatedCount?: number;\n}\n/**\n * The options to query\n */\nexport interface QueryOption {\n    /**\n     * Additional header\n     */\n    headers?: Record<string, any>;\n    /**\n     * The user agent in nodejs of https\n     */\n    userAgent?: Agent;\n}\n/**\n * Cached minecraft section name to id\n */\nexport declare enum MinecraftSection {\n    MapandInformation = 423,\n    Addons = 426,\n    ArmorToolsAndWeapons = 434,\n    Structures = 409,\n    BloodMagic = 4485,\n    Storage = 420,\n    IndustrialCraft = 429,\n    Magic = 419,\n    Technology = 412,\n    Redstone = 4558,\n    TinkersConstruct = 428,\n    PlayerTransport = 414,\n    LuckyBlocks = 4486,\n    Buildcraft = 432,\n    Genetics = 418,\n    TwitchIntegration = 4671,\n    OresandResources = 408,\n    CraftTweaker = 4773,\n    Thaumcraft = 430,\n    AdventureandRPG = 422,\n    Processing = 413,\n    Energy = 417,\n    EnergyFluidAndItemTransport = 415,\n    Forestry = 433,\n    Miscellaneous = 425,\n    AppliedEnergistics2 = 4545,\n    Farming = 416,\n    APIandLibrary = 421,\n    Cosmetic = 424,\n    Fabric = 4780,\n    WorldGen = 406,\n    Mobs = 411,\n    Biomes = 407,\n    ThermalExpansion = 427,\n    ServerUtility = 435,\n    Dimensions = 410,\n    Food = 436\n}\n/**\n * Get the addon by addon Id.\n * @param addonID The id of addon\n * @param options The query options\n */\nexport declare function getAddonInfo(addonID: number, options?: QueryOption): Promise<AddonInfo>;\n/**\n * Get the list of addon by addon ids.\n */\nexport declare function getAddons(addonIDs: number[], options?: QueryOption): Promise<AddonInfo[]>;\n/**\n * Search addons by keyword.\n */\nexport declare function searchAddons(searchOptions: SearchOptions, options?: QueryOption): Promise<AddonInfo[]>;\n/**\n * Get the addon project description HTML string.\n *\n * @returns The string of description HTML.\n */\nexport declare function getAddonDescription(addonID: number, options?: QueryOption): Promise<string>;\n/**\n * Get the content of the changelog of a addon's file\n */\nexport declare function getAddonFileChangelog(addonID: number, fileID: number, options?: QueryOption): Promise<string>;\nexport declare function getAddonFileInfo(addonID: number, fileID: number, options?: QueryOption): Promise<File[]>;\n/**\n * Return the addon file download url string.\n */\nexport declare function getAddonFileDownloadURL(addonID: number, fileID: number, options?: QueryOption): Promise<string>;\n/**\n * Get the file list of the addon.\n */\nexport declare function getAddonFiles(addonID: number, options?: QueryOption): Promise<File[]>;\n/**\n * Get the addon data base timestamp in string of \\`Date\\`, like \"2019-06-09T23:34:29.103Z\".\n */\nexport declare function getAddonDatabaseTimestamp(options?: QueryOption): Promise<string>;\n/**\n * Select several addons for the game.\n */\nexport declare function getFeaturedAddons(getOptions?: GetFeaturedAddonOptions, options?: QueryOption): Promise<AddonInfo[]>;\n/**\n * Get the list of category. You can use the \\`category.id\\` in params of \\`searchAddon\\` function.\n */\nexport declare function getCategories(options?: QueryOption): Promise<Category[]>;\n/**\n * Get the timestamp of the categories data base.\n * It should return the \\`Date\\` string like \"2019-06-09T23:34:29.103Z\"\n */\nexport declare function getCategoryTimestamp(options?: QueryOption): Promise<any>;\n`;\nmodule.exports['@xmcl/curseforge/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/forge-site-parser/index.d.ts'] = `/**\n * One forge version download info\n */\ninterface Download {\n    md5: string;\n    sha1: string;\n    path: string;\n}\n/**\n * Parse the html string of forge webpage\n */\nexport declare function parse(content: string): ForgeWebPage;\n/**\n * A richer version info than forge installer required\n */\ninterface Version {\n    /**\n     * The minecraft version\n     */\n    mcversion: string;\n    /**\n     * The version of forge\n     */\n    version: string;\n    date: string;\n    /**\n     * The changelog info\n     */\n    changelog?: Download;\n    installer: Download;\n    mdk?: Download;\n    universal: Download;\n    source?: Download;\n    launcher?: Download;\n    /**\n     * The type of the forge release. The \\`common\\` means the normal release.\n     */\n    type: \"buggy\" | \"recommended\" | \"common\" | \"latest\";\n}\n/**\n * Forge webpack contains the forge versions for a Minecraft version.\n */\nexport interface ForgeWebPage {\n    versions: Version[];\n    mcversion: string;\n}\nexport {};\n`;\nmodule.exports['@xmcl/forge-site-parser/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/gamesetting/index.d.ts'] = `export declare enum AmbientOcclusion {\n    Off = 0,\n    Minimum = 1,\n    Maximum = 2\n}\nexport declare enum Particles {\n    Minimum = 2,\n    Decreased = 1,\n    All = 0\n}\nexport declare enum Difficulty {\n    Peaceful = 0,\n    Easy = 1,\n    Normal = 2,\n    Hard = 3\n}\nexport declare type MipmapLevel = 0 | 1 | 2 | 3 | 4;\nexport declare type RenderDistance = 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32;\nexport declare const RenderDistance: Readonly<{\n    Tiny: number;\n    Short: number;\n    Normal: number;\n    Far: number;\n    Extreme: number;\n}>;\nexport declare const Graphic: Readonly<{\n    Fast: boolean;\n    Fancy: boolean;\n}>;\nexport declare type Graphic = boolean;\nexport declare const RenderCloud: Readonly<{\n    Off: boolean;\n    Fast: string;\n    Fancy: boolean;\n}>;\nexport declare type RenderCloud = true | false | \"fast\";\nexport declare enum KeyCode {\n    \"Escape\" = 1,\n    \"Digit1\" = 2,\n    \"Digit2\" = 3,\n    \"Digit3\" = 4,\n    \"Digit4\" = 5,\n    \"Digit5\" = 6,\n    \"Digit6\" = 7,\n    \"Digit7\" = 8,\n    \"Digit8\" = 9,\n    \"Digit9\" = 10,\n    \"Digit0\" = 11,\n    \"Minus\" = 12,\n    \"Equal\" = 13,\n    \"Backspace\" = 14,\n    \"Tab\" = 15,\n    \"KeyQ\" = 16,\n    \"KeyW\" = 17,\n    \"KeyE\" = 18,\n    \"KeyR\" = 19,\n    \"KeyT\" = 20,\n    \"KeyY\" = 21,\n    \"KeyU\" = 22,\n    \"KeyI\" = 23,\n    \"KeyO\" = 24,\n    \"KeyP\" = 25,\n    \"BracketLeft\" = 26,\n    \"BracketRight\" = 27,\n    \"Enter\" = 28,\n    \"ControlLeft\" = 29,\n    \"KeyA\" = 30,\n    \"KeyS\" = 31,\n    \"KeyD\" = 32,\n    \"KeyF\" = 33,\n    \"KeyG\" = 34,\n    \"KeyH\" = 35,\n    \"KeyJ\" = 36,\n    \"KeyK\" = 37,\n    \"KeyL\" = 38,\n    \"Semicolon\" = 39,\n    \"Quote\" = 40,\n    \"Backquote\" = 41,\n    \"ShiftLeft\" = 42,\n    \"Backslash\" = 43,\n    \"KeyZ\" = 44,\n    \"KeyX\" = 45,\n    \"KeyC\" = 46,\n    \"KeyV\" = 47,\n    \"KeyB\" = 48,\n    \"KeyN\" = 49,\n    \"KeyM\" = 50,\n    \"Comma\" = 51,\n    \"Period\" = 52,\n    \"Slash\" = 53,\n    \"ShiftRight\" = 54,\n    \"Space\" = 57,\n    \"CapsLock\" = 58,\n    \"F1\" = 59,\n    \"F2\" = 60,\n    \"F3\" = 61,\n    \"F4\" = 62,\n    \"F5\" = 63,\n    \"F6\" = 64,\n    \"F7\" = 65,\n    \"F8\" = 66,\n    \"F9\" = 67,\n    \"F10\" = 68,\n    \"NumLock\" = 69,\n    \"ScrollLock\" = 70,\n    \"Numpad7\" = 71,\n    \"Numpad8\" = 72,\n    \"Numpad9\" = 73,\n    \"NumpadSubtract\" = 74,\n    \"Numpad4\" = 75,\n    \"Numpad5\" = 76,\n    \"Numpad6\" = 77,\n    \"NumpadAdd\" = 78,\n    \"Numpad1\" = 79,\n    \"Numpad2\" = 80,\n    \"Numpad3\" = 81,\n    \"Numpad0\" = 82,\n    \"NumpadDecimal\" = 83,\n    \"F11\" = 87,\n    \"F12\" = 88,\n    \"F13\" = 100,\n    \"F14\" = 101,\n    \"F15\" = 102,\n    \"F16\" = 103,\n    \"F17\" = 104,\n    \"F18\" = 105,\n    \"ControlRight\" = 157,\n    \"ArrowUp\" = 200,\n    \"ArrowLeft\" = 203,\n    \"ArrowRight\" = 205,\n    \"ArrowDown\" = 208,\n    \"MULTIPLY\" = 55,\n    \"Left Menu/Alt\" = 56,\n    \"NumpadEnter\" = 156,\n    \"NumpadComma\" = 179,\n    \"Home\" = 199,\n    \"PageUp\" = 201,\n    \"End\" = 207,\n    \"PageDown\" = 209,\n    \"Insert\" = 210,\n    \"Delete\" = 211,\n    \"MouseLeft\" = -100,\n    \"MouseRight\" = -99,\n    \"MouseMiddle\" = -98\n}\ndeclare const DEFAULT_FRAME: {\n    version: number;\n    invertYMouse: boolean;\n    mouseSensitivity: number;\n    difficulty: Difficulty;\n    renderDistance: RenderDistance;\n    particles: Particles;\n    fboEnable: boolean;\n    fancyGraphics: boolean;\n    ao: AmbientOcclusion;\n    renderClouds: RenderCloud;\n    enableVsync: boolean;\n    useVbo: boolean;\n    mipmapLevels: MipmapLevel;\n    anaglyph3d: boolean;\n    fov: number;\n    gamma: number;\n    saturation: number;\n    guiScale: number;\n    bobView: boolean;\n    maxFps: number;\n    fullscreen: boolean;\n    resourcePacks: string[];\n    incompatibleResourcePacks: string[];\n    lastServer: string;\n    lang: string;\n    chatVisibility: number;\n    chatColors: boolean;\n    chatLinks: boolean;\n    chatLinksPrompt: boolean;\n    chatOpacity: number;\n    snooperEnabled: boolean;\n    hideServerAddress: boolean;\n    advancedItemTooltips: boolean;\n    pauseOnLostFocus: boolean;\n    touchscreen: boolean;\n    overrideWidth: number;\n    overrideHeight: number;\n    heldItemTooltips: boolean;\n    chatHeightFocused: number;\n    chatHeightUnfocused: number;\n    chatScale: number;\n    chatWidth: number;\n    forceUnicodeFont: boolean;\n    reducedDebugInfo: boolean;\n    useNativeTransport: boolean;\n    entityShadows: boolean;\n    mainHand: string;\n    attackIndicator: number;\n    showSubtitles: boolean;\n    realmsNotifications: boolean;\n    enableWeakAttacks: boolean;\n    autoJump: boolean;\n    narrator: number;\n    tutorialStep: string;\n    \"key_key.attack\": KeyCode;\n    \"key_key.use\": KeyCode;\n    \"key_key.forward\": KeyCode;\n    \"key_key.left\": KeyCode;\n    \"key_key.back\": KeyCode;\n    \"key_key.right\": KeyCode;\n    \"key_key.jump\": KeyCode;\n    \"key_key.sneak\": KeyCode;\n    \"key_key.sprint\": KeyCode;\n    \"key_key.drop\": KeyCode;\n    \"key_key.inventory\": KeyCode;\n    \"key_key.chat\": KeyCode;\n    \"key_key.playerlist\": KeyCode;\n    \"key_key.pickItem\": KeyCode;\n    \"key_key.command\": KeyCode;\n    \"key_key.screenshot\": KeyCode;\n    \"key_key.togglePerspective\": KeyCode;\n    \"key_key.smoothCamera\": KeyCode;\n    \"key_key.fullscreen\": KeyCode;\n    \"key_key.spectatorOutlines\": KeyCode;\n    \"key_key.swapHands\": KeyCode;\n    \"key_key.saveToolbarActivator\": KeyCode;\n    \"key_key.loadToolbarActivator\": KeyCode;\n    \"key_key.advancements\": KeyCode;\n    \"key_key.hotbar.1\": KeyCode;\n    \"key_key.hotbar.2\": KeyCode;\n    \"key_key.hotbar.3\": KeyCode;\n    \"key_key.hotbar.4\": KeyCode;\n    \"key_key.hotbar.5\": KeyCode;\n    \"key_key.hotbar.6\": KeyCode;\n    \"key_key.hotbar.7\": KeyCode;\n    \"key_key.hotbar.8\": KeyCode;\n    \"key_key.hotbar.9\": KeyCode;\n    soundCategory_master: KeyCode;\n    soundCategory_music: KeyCode;\n    soundCategory_record: KeyCode;\n    soundCategory_weather: KeyCode;\n    soundCategory_block: KeyCode;\n    soundCategory_hostile: KeyCode;\n    soundCategory_neutral: KeyCode;\n    soundCategory_player: KeyCode;\n    soundCategory_ambient: KeyCode;\n    soundCategory_voice: KeyCode;\n    modelPart_cape: boolean;\n    modelPart_jacket: boolean;\n    modelPart_left_sleeve: boolean;\n    modelPart_right_sleeve: boolean;\n    modelPart_left_pants_leg: boolean;\n    modelPart_right_pants_leg: boolean;\n    modelPart_hat: boolean;\n};\nexport declare type FullFrame = typeof DEFAULT_FRAME;\nexport declare type Frame = Partial<FullFrame>;\nexport declare function getDefaultFrame(): FullFrame;\nexport declare type ModelPart = \"cape\" | \"jacket\" | \"left_sleeve\" | \"right_sleeve\" | \"left_pants_leg\" | \"right_pants_leg\" | \"hat\";\nexport declare type SoundCategories = \"master\" | \"music\" | \"record\" | \"weather\" | \"block\" | \"hostile\" | \"neutral\" | \"player\" | \"ambient\" | \"voice\";\nexport declare type HotKeys = \"attack\" | \"use\" | \"forward\" | \"left\" | \"back\" | \"right\" | \"jump\" | \"sneak\" | \"sprint\" | \"drop\" | \"inventory\" | \"chat\" | \"playerlist\" | \"pickItem\" | \"command\" | \"screenshot\" | \"togglePerspective\" | \"smoothCamera\" | \"fullscreen\" | \"spectatorOutlines\" | \"swapHands\" | \"saveToolbarActivator\" | \"loadToolbarActivator\" | \"advancements\" | \"hotbar.1\" | \"hotbar.2\" | \"hotbar.3\" | \"hotbar.4\" | \"hotbar.5\" | \"hotbar.6\" | \"hotbar.7\" | \"hotbar.8\" | \"hotbar.9\";\n/**\n * Parse raw game setting options.txt content\n *\n * @param str the options.txt content\n * @param strict strictly follow the current version of options format (outdate version might cause problem. If your options.txt is new one with new fields, don't turn on this)\n */\nexport declare function parse(str: string, strict?: boolean): GameSetting | Frame;\n/**\n * Generate text format game setting for options.txt file.\n *\n * @param setting The game setting object\n * @param original\n * @param eol The end of line character, default is \\`\\n\\`\n */\nexport declare function stringify(setting: GameSetting | Frame | any, original?: string, eol?: string): string;\nexport declare type GameSetting = ReturnType<typeof getDefaultFrame>;\nexport {};\n`;\nmodule.exports['@xmcl/gamesetting/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/installer/curseforge.d.ts'] = `/// <reference types=\"node\" />\nimport { MinecraftFolder, MinecraftLocation } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { CachedZipFile } from \"@xmcl/unzip\";\nimport { DownloaderOption } from \"./minecraft\";\nexport interface Options extends DownloaderOption {\n    /**\n     * The function to query a curseforge project downloadable url.\n     */\n    queryFileUrl?: CurseforgeURLQuery;\n    /**\n     * Should it replace the override files if the file is existed.\n     */\n    replaceExisted?: boolean;\n    /**\n     * Overload the manifest for this installation.\n     * It will use this manifest instead of the read manifest from modpack zip to install.\n     */\n    manifest?: Manifest;\n    /**\n     * The function to resolve the file path from url and other.\n     *\n     * By default this will install all the file\n     */\n    filePathResolver?: FilePathResolver;\n}\nexport interface InstallFileOptions extends DownloaderOption {\n    /**\n     * The function to query a curseforge project downloadable url.\n     */\n    queryFileUrl?: CurseforgeURLQuery;\n}\ndeclare type InputType = string | Buffer | CachedZipFile;\nexport interface Manifest {\n    manifestType: string;\n    manifestVersion: number;\n    minecraft: {\n        /**\n         * Minecraft version\n         */\n        version: string;\n        libraries?: string;\n        /**\n         * Can be forge\n         */\n        modLoaders: {\n            id: string;\n            primary: boolean;\n        }[];\n    };\n    name: string;\n    version: string;\n    author: string;\n    files: {\n        projectID: number;\n        fileID: number;\n        required: boolean;\n    }[];\n    overrides: string;\n}\nexport interface File {\n    projectID: number;\n    fileID: number;\n}\n/**\n * Read the mainifest data from modpack\n */\nexport declare function readManifestTask(zip: InputType): Task<Manifest>;\n/**\n * Read the mainifest data from modpack\n */\nexport declare function readManifest(zip: InputType): Promise<Manifest>;\nexport declare type FilePathResolver = (projectId: number, fileId: number, minecraft: MinecraftFolder, url: string) => string | Promise<string>;\nexport declare type CurseforgeURLQuery = (projectId: number, fileId: number) => Promise<string>;\nexport declare type CurseforgeFileTypeQuery = (projectId: number) => Promise<\"mods\" | \"resourcepacks\">;\nexport declare function createDefaultCurseforgeQuery(): CurseforgeURLQuery;\n/**\n * Install curseforge modpack to a specific Minecraft location.\n *\n * @param zip The curseforge modpack zip buffer or file path\n * @param minecraft The minecraft location\n * @param options The options for query curseforge\n */\nexport declare function installCurseforgeModpack(zip: InputType, minecraft: MinecraftLocation, options?: Options): Promise<Manifest>;\n/**\n * Install curseforge modpack to a specific Minecraft location.\n *\n * This will NOT install the Minecraft version in the modpack, and will NOT install the forge or other modload listed in modpack!\n * Please resolve them by yourself.\n *\n * @param zip The curseforge modpack zip buffer or file path\n * @param minecraft The minecraft location\n * @param options The options for query curseforge\n */\nexport declare function installCurseforgeModpackTask(zip: InputType, minecraft: MinecraftLocation, options?: Options): Task<Manifest>;\n/**\n * Install a cureseforge xml file to a specific locations\n */\nexport declare function installCurseforgeFile(file: File, destination: string, options?: InstallFileOptions): Promise<void>;\n/**\n * Install a cureseforge xml file to a specific locations\n */\nexport declare function installCurseforgeFileTask(file: File, destination: string, options?: InstallFileOptions): Task<void>;\nexport {};\n`;\nmodule.exports['@xmcl/installer/diagnose.d.ts'] = `import { MinecraftFolder, MinecraftLocation, ResolvedLibrary } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { InstallProfile } from \"./minecraft\";\ndeclare type Processor = InstallProfile[\"processors\"][number];\nexport interface Issue {\n    /**\n     * The type of the issue.\n     */\n    type: \"missing\" | \"corrupted\";\n    /**\n     * The role of the file in Minecraft.\n     */\n    role: \"minecraftJar\" | \"versionJson\" | \"library\" | \"asset\" | \"assetIndex\" | \"processor\";\n    /**\n     * The path of the problematic file.\n     */\n    file: string;\n    /**\n     * The useful hint to fix this issue. This should be a human readable string.\n     */\n    hint: string;\n    /**\n     * The expected checksum of the file. Can be an empty string if this file is missing or not check checksum at all!\n     */\n    expectedChecksum: string;\n    /**\n     * The actual checksum of the file. Can be an empty string if this file is missing or not check checksum at all!\n     */\n    receivedChecksum: string;\n}\nexport declare type MinecraftIssues = LibraryIssue | MinecraftJarIssue | VersionJsonIssue | AssetIssue | AssetIndexIssue;\nexport declare type InstallIssues = ProcessorIssue | LibraryIssue;\n/**\n * The processor issue\n */\nexport interface ProcessorIssue extends Issue {\n    role: \"processor\";\n    /**\n     * The processor\n     */\n    processor: Processor;\n}\n/**\n * The library issue represents a corrupted or missing lib.\n * You can use \\`Installer.installResolvedLibraries\\` to fix this.\n */\nexport interface LibraryIssue extends Issue {\n    role: \"library\";\n    /**\n     * The problematic library\n     */\n    library: ResolvedLibrary;\n}\n/**\n * The minecraft jar issue represents a corrupted or missing minecraft jar.\n * You can use \\`Installer.installVersion\\` to fix this.\n */\nexport interface MinecraftJarIssue extends Issue {\n    role: \"minecraftJar\";\n    /**\n     * The minecraft version for that jar\n     */\n    version: string;\n}\n/**\n * The minecraft jar issue represents a corrupted or missing version jar.\n *\n * This means your version is totally broken, and you should reinstall this version.\n *\n * - If this is just a Minecraft version, you will need to use \\`Installer.install\\` to re-install Minecraft.\n * - If this is a Forge version, you will need to use \\`ForgeInstaller.install\\` to re-install.\n * - Others are the same, just re-install\n */\nexport interface VersionJsonIssue extends Issue {\n    role: \"versionJson\";\n    /**\n     * The version of version json that has problem.\n     */\n    version: string;\n}\n/**\n * The asset issue represents a corrupted or missing minecraft asset file.\n * You can use \\`Installer.installResolvedAssets\\` to fix this.\n */\nexport interface AssetIssue extends Issue {\n    role: \"asset\";\n    /**\n     * The problematic asset\n     */\n    asset: {\n        name: string;\n        hash: string;\n        size: number;\n    };\n}\n/**\n * The asset index issue represents a corrupted or missing minecraft asset index file.\n * You can use \\`Installer.installAssets\\` to fix this.\n */\nexport interface AssetIndexIssue extends Issue {\n    role: \"assetIndex\";\n    /**\n     * The minecraft version of the asset index\n     */\n    version: string;\n}\nexport interface MinecraftIssueReport {\n    minecraftLocation: MinecraftFolder;\n    version: string;\n    issues: MinecraftIssues[];\n}\nexport interface InstallProfileIssueReport {\n    minecraftLocation: MinecraftFolder;\n    installProfile: InstallProfile;\n    issues: InstallIssues[];\n}\n/**\n * Diagnose the version. It will check the version json/jar, libraries and assets.\n *\n * @param version The version id string\n * @param minecraft The minecraft location\n * @beta\n */\nexport declare function diagnoseTask(version: string, minecraftLocation: MinecraftLocation): Task<MinecraftIssueReport>;\n/**\n * Diagnose the version. It will check the version json/jar, libraries and assets.\n * @beta\n *\n * @param version The version id string\n * @param minecraft The minecraft location\n */\nexport declare function diagnose(version: string, minecraft: MinecraftLocation): Promise<MinecraftIssueReport>;\n/**\n * Diagnose a install profile status. Check if it processor output correctly processed.\n *\n * This can be used for check if forge correctly installed when minecraft >= 1.13\n * @beta\n *\n * @param installProfile The install profile.\n * @param minecraftLocation The minecraft location\n */\nexport declare function diagnoseInstallTask(installProfile: InstallProfile, minecraftLocation: MinecraftLocation): Task<InstallProfileIssueReport>;\n/**\n * Diagnose a install profile status. Check if it processor output correctly processed.\n *\n * This can be used for check if forge correctly installed when minecraft >= 1.13\n * @beta\n *\n * @param installProfile The install profile.\n * @param minecraftLocation The minecraft location\n */\nexport declare function diagnoseInstall(installProfile: InstallProfile, minecraftLocation: MinecraftLocation): Promise<InstallProfileIssueReport>;\nexport {};\n`;\nmodule.exports['@xmcl/installer/fabric.d.ts'] = `import { MinecraftLocation } from \"@xmcl/core\";\nimport { InstallOptions, UpdatedObject } from \"./util\";\nexport declare const YARN_MAVEN_URL = \"https://maven.fabricmc.net/net/fabricmc/yarn/maven-metadata.xml\";\nexport declare const LOADER_MAVEN_URL = \"https://maven.fabricmc.net/net/fabricmc/fabric-loader/maven-metadata.xml\";\n/**\n * Fabric Yarn version list\n * @see https://github.com/FabricMC/yarn\n */\nexport interface YarnVersionList extends UpdatedObject {\n    versions: string[];\n}\n/**\n * Fabric mod loader version list\n * @see https://fabricmc.net/\n */\nexport interface LoaderVersionList extends UpdatedObject {\n    versions: string[];\n}\nexport interface FabricArtifactVersion {\n    gameVersion?: string;\n    separator?: string;\n    build?: number;\n    maven: string;\n    version: string;\n    stable: boolean;\n}\nexport interface FabricArtifacts {\n    mappings: FabricArtifactVersion[];\n    loader: FabricArtifactVersion[];\n}\nexport interface LoaderArtifact {\n    loader: FabricArtifactVersion;\n    launcherMeta: {\n        version: number;\n        libraries: {\n            client: {\n                name: string;\n                url: string;\n            }[];\n            common: {\n                name: string;\n                url: string;\n            }[];\n            server: {\n                name: string;\n                url: string;\n            }[];\n        };\n        mainClass: {\n            client: string;\n            server: string;\n        };\n    };\n}\nexport declare const DEFAULT_FABRIC_API = \"https://meta.fabricmc.net/v2\";\n/**\n * Get all the artifacts provided by fabric\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getArtifacts(remote?: string): Promise<FabricArtifacts>;\n/**\n * Get fabric-yarn artifact list\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getYarnArtifactList(remote?: string): Promise<FabricArtifactVersion[]>;\n/**\n * Get fabric-yarn artifact list by Minecraft version\n * @param minecraft The Minecraft version\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getYarnArtifactListFor(minecraft: string, remote?: string): Promise<FabricArtifactVersion[]>;\n/**\n * Get fabric-loader artifact list\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getLoaderArtifactList(remote?: string): Promise<FabricArtifactVersion[]>;\n/**\n * Get fabric-loader artifact list by Minecraft version\n * @param minecraft The minecraft version\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getLoaderArtifactListFor(minecraft: string, remote?: string): Promise<LoaderArtifact[]>;\n/**\n * Get fabric-loader artifact list by Minecraft version\n * @param minecraft The minecraft version\n * @param loader The yarn-loader version\n * @param remote The fabric API host\n * @beta\n */\nexport declare function getLoaderArtifact(minecraft: string, loader: string, remote?: string): Promise<LoaderArtifact>;\n/**\n * Parse the maven xml provided by Fabric. This is pretty tricky. I don't want to include another lib to parse xml.\n * Therefore I just use RegExp here to match.\n *\n * @param content The xml string from Fabric.\n */\nexport declare function parseVersionMavenXML(content: string): string[];\n/**\n * Get or refresh the yarn version list.\n */\nexport declare function getYarnVersionList(option?: {\n    /**\n     * If this presents, it will send request with the original list timestamp.\n     *\n     * If the server believes there is no modification after the original one,\n     * it will directly return the orignal one.\n     */\n    original?: YarnVersionList;\n    /**\n     * remote maven xml url of this request\n     */\n    remote?: string;\n}): Promise<YarnVersionList>;\n/**\n * Get or refresh the fabric mod loader version list.\n */\nexport declare function getLoaderVersionList(option: {\n    /**\n     * If this presents, it will send request with the original list timestamp.\n     *\n     * If the server believes there is no modification after the original one,\n     * it will directly return the orignal one.\n     */\n    original?: LoaderVersionList;\n    /**\n     * remote maven xml url of this request\n     */\n    remote?: string;\n}): Promise<LoaderVersionList>;\n/**\n * Install the fabric to the client. Notice that this will only install the json.\n * You need to call \\`Installer.installDependencies\\` to get a full client.\n * @param yarnVersion The yarn version\n * @param loaderVersion The fabric loader version\n * @param minecraft The minecraft location\n * @returns The installed version id\n */\nexport declare function install(yarnVersion: string, loaderVersion: string, minecraft: MinecraftLocation, options?: InstallOptions): Promise<string>;\n/**\n * Generate fabric version json to the disk according to yarn and loader\n * @param side Client or server\n * @param yarnVersion The yarn version string or artifact\n * @param loader The loader artifact\n * @param minecraft The Minecraft Location\n * @param options The options\n * @beta\n */\nexport declare function installFromVersionMeta(side: \"client\" | \"server\", yarnVersion: string | FabricArtifactVersion, loader: LoaderArtifact, minecraft: MinecraftLocation, options?: InstallOptions): Promise<string>;\n`;\nmodule.exports['@xmcl/installer/forge.d.ts'] = `import { MinecraftLocation } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { DownloaderOption, InstallProfileOption, LibraryOption } from \"./minecraft\";\nimport { InstallOptions as InstallOptionsBase, UpdatedObject } from \"./util\";\nexport interface VersionList extends UpdatedObject {\n    mcversion: string;\n    versions: Version[];\n}\n/**\n * The forge version metadata to download a forge\n */\nexport interface Version {\n    /**\n     * The installer info\n     */\n    installer: {\n        md5: string;\n        sha1: string;\n        /**\n         * The url path to concat with forge maven\n         */\n        path: string;\n    };\n    universal: {\n        md5: string;\n        sha1: string;\n        /**\n         * The url path to concat with forge maven\n         */\n        path: string;\n    };\n    /**\n     * The minecraft version\n     */\n    mcversion: string;\n    /**\n     * The forge version (without minecraft version)\n     */\n    version: string;\n    type: \"buggy\" | \"recommended\" | \"common\" | \"latest\";\n}\ndeclare type RequiredVersion = {\n    /**\n     * The installer info.\n     *\n     * If this is not presented, it will genreate from mcversion and forge version.\n     */\n    installer?: {\n        sha1?: string;\n        /**\n         * The url path to concat with forge maven\n         */\n        path: string;\n    };\n    universal?: {\n        sha1?: string;\n        /**\n         * The url path to concat with forge maven\n         */\n        path: string;\n    };\n    /**\n     * The minecraft version\n     */\n    mcversion: string;\n    /**\n     * The forge version (without minecraft version)\n     */\n    version: string;\n};\nexport declare const DEFAULT_FORGE_MAVEN = \"http://files.minecraftforge.net/maven\";\n/**\n * The options to install forge.\n */\nexport interface Options extends DownloaderOption, LibraryOption, InstallOptionsBase, InstallProfileOption {\n}\n/**\n * Install forge to target location.\n * Installation task for forge with mcversion >= 1.13 requires java installed on your pc.\n * @param version The forge version meta\n * @returns The installed version name.\n */\nexport declare function install(version: RequiredVersion, minecraft: MinecraftLocation, options?: Options): Promise<string>;\n/**\n * Install forge to target location.\n * Installation task for forge with mcversion >= 1.13 requires java installed on your pc.\n * @param version The forge version meta\n * @returns The task to install the forge\n */\nexport declare function installTask(version: RequiredVersion, minecraft: MinecraftLocation, options?: Options): Task<string>;\n/**\n * Query the webpage content from files.minecraftforge.net.\n *\n * You can put the last query result to the fallback option. It will check if your old result is up-to-date.\n * It will request a new page only when the fallback option is outdated.\n *\n * @param option The option can control querying minecraft version, and page caching.\n */\nexport declare function getVersionList(option?: {\n    /**\n     * The minecraft version you are requesting\n     */\n    mcversion?: string;\n    /**\n     * If this presents, it will send request with the original list timestamp.\n     *\n     * If the server believes there is no modification after the original one,\n     * it will directly return the orignal one.\n     */\n    original?: VersionList;\n}): Promise<VersionList>;\nexport {};\n`;\nmodule.exports['@xmcl/installer/index.d.ts'] = `import * as FabricInstaller from \"./fabric\";\nimport * as LiteLoaderInstaller from \"./liteloader\";\nimport * as ForgeInstaller from \"./forge\";\nimport * as Installer from \"./minecraft\";\nimport * as CurseforgeInstaller from \"./curseforge\";\nimport * as OptifineInstaller from \"./optifine\";\nimport * as JavaInstaller from \"./java\";\nimport * as Diagnosis from \"./diagnose\";\nexport { DownloadOption, Downloader, DefaultDownloader, MultipleError, downloadFileTask, InstallOptions, DownloaderOptions } from \"./util\";\nexport { JavaInstaller, Installer, ForgeInstaller, LiteLoaderInstaller, FabricInstaller, Diagnosis, CurseforgeInstaller, OptifineInstaller };\n`;\nmodule.exports['@xmcl/installer/java.d.ts'] = `import { Task } from \"@xmcl/task\";\nimport { DownloaderOption } from \"./minecraft\";\nexport interface JavaInfo {\n    /**\n     * Full java executable path\n     */\n    path: string;\n    /**\n     * Java version string\n     */\n    version: string;\n    /**\n     * Major version of java\n     */\n    majorVersion: number;\n}\nexport interface Options extends DownloaderOption {\n    /**\n     * The destination of this installation\n     */\n    destination: string;\n    /**\n     * The cached directory which compressed java lzma will be download to.\n     * @default os.tempdir()\n     */\n    cacheDir?: string;\n    /**\n     * Unpack lzma function. It must present, else it will not be able to unpack mojang provided LZMA.\n     */\n    unpackLZMA: (src: string, dest: string) => Promise<void>;\n}\n/**\n * Install JRE from Mojang offical resource. It should install jdk 8.\n * @param options The install options\n */\nexport declare function installJreFromMojangTask(options: Options): Task<void>;\n/**\n * Install JRE from Mojang offical resource. It should install jdk 8.\n * @param options The install options\n */\nexport declare function installJreFromMojang(options: Options): Promise<void>;\n/**\n * Try to resolve a java info at this path. This will call \\`java -version\\`\n * @param path The java exectuable path.\n */\nexport declare function resolveJava(path: string): Promise<JavaInfo | undefined>;\n/**\n * Parse version string and major version number from stderr of java process.\n *\n * @param versionText The stderr for \\`java -version\\`\n */\nexport declare function parseJavaVersion(versionText: string): {\n    version: string;\n    majorVersion: number;\n} | undefined;\n/**\n * Get all potential java locations for Minecraft.\n *\n * On mac/linux, it will perform \\`which java\\`. On win32, it will perform \\`where java\\`\n *\n * @returns The absolute java locations path\n */\nexport declare function getPotentialJavaLocations(): Promise<string[]>;\n/**\n * Scan local java version on the disk.\n *\n * It will check if the passed \\`locations\\` are the home of java.\n * Notice that the locations should not be the executable, but the path of java installation, like JAVA_HOME.\n *\n * This will call \\`getPotentialJavaLocations\\` and then \\`resolveJava\\`\n *\n * @param locations The location (like java_home) want to check.\n * @returns All validate java info\n */\nexport declare function scanLocalJava(locations: string[]): Promise<JavaInfo[]>;\n`;\nmodule.exports['@xmcl/installer/liteloader.d.ts'] = `import { MinecraftLocation } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { UpdatedObject, InstallOptions } from \"./util\";\nexport declare const DEFAULT_VERSION_MANIFEST = \"http://dl.liteloader.com/versions/versions.json\";\n/**\n * The liteloader version list. Containing the minecraft version -> liteloader version info mapping.\n */\nexport interface VersionList extends UpdatedObject {\n    meta: {\n        description: string;\n        authors: string;\n        url: string;\n        updated: string;\n        updatedTime: number;\n    };\n    versions: {\n        [version: string]: {\n            snapshot?: Version;\n            release?: Version;\n        };\n    };\n}\nexport declare namespace VersionList {\n    function parse(content: string): {\n        meta: any;\n        versions: {};\n    };\n}\n/**\n * A liteloader remote version information\n */\nexport interface Version {\n    version: string;\n    url: string;\n    file: string;\n    mcversion: string;\n    type: \"RELEASE\" | \"SNAPSHOT\";\n    md5: string;\n    timestamp: string;\n    libraries: Array<{\n        name: string;\n        url?: string;\n    }>;\n    tweakClass: string;\n}\n/**\n * Get or update the LiteLoader version list.\n *\n * This will request liteloader offical json by default. You can replace the request by assigning the remote option.\n */\nexport declare function getVersionList(option?: {\n    /**\n     * If this presents, it will send request with the original list timestamp.\n     *\n     * If the server believes there is no modification after the original one,\n     * it will directly return the orignal one.\n     */\n    original?: VersionList;\n    /**\n     * The optional requesting version json url.\n     */\n    remote?: string;\n}): Promise<VersionList>;\n/**\n * Install the liteloader to specific minecraft location.\n *\n * This will install the liteloader amount on the corresponded Minecraft version by default.\n * If you want to install over the forge. You should first install forge and pass the installed forge version id to the third param,\n * like \\`1.12-forge-xxxx\\`\n *\n * @param versionMeta The liteloader version metadata.\n * @param location The minecraft location you want to install\n * @param version The real existed version id (under the the provided minecraft location) you want to installed liteloader inherit\n */\nexport declare function install(versionMeta: Version, location: MinecraftLocation, options?: InstallOptions): Promise<string>;\n/**\n * Install the liteloader to specific minecraft location.\n *\n * This will install the liteloader amount on the corresponded Minecraft version by default.\n * If you want to install over the forge. You should first install forge and pass the installed forge version id to the third param,\n * like \\`1.12-forge-xxxx\\`\n *\n * @tasks installLiteloader, installLiteloader.resolveVersionJson installLiteloader.generateLiteloaderJson\n *\n * @param versionMeta The liteloader version metadata.\n * @param location The minecraft location you want to install\n * @param version The real existed version id (under the the provided minecraft location) you want to installed liteloader inherit\n */\nexport declare function installTask(versionMeta: Version, location: MinecraftLocation, options?: InstallOptions): Task<string>;\n`;\nmodule.exports['@xmcl/installer/minecraft.d.ts'] = `import { MinecraftFolder, MinecraftLocation, ResolvedLibrary, ResolvedVersion, Version as VersionJson } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { DownloaderOptions, UpdatedObject } from \"./util\";\n/**\n * The function to swap library host.\n */\nexport declare type LibraryHost = (library: ResolvedLibrary) => string | string[] | undefined;\n/**\n * The version metadata containing the version information, like download url\n */\nexport interface Version {\n    id: string;\n    type: string;\n    time: string;\n    releaseTime: string;\n    url: string;\n}\n/**\n * Minecraft version metadata list\n */\nexport interface VersionList extends UpdatedObject {\n    latest: {\n        /**\n         * Snapshot version id of the Minecraft\n         */\n        snapshot: string;\n        /**\n         * Release version id of the Minecraft, like 1.14.2\n         */\n        release: string;\n    };\n    /**\n     * All the vesrsion list\n     */\n    versions: Version[];\n}\nexport interface InstallProfile {\n    spec?: number;\n    /**\n     * The type of this installation, like \"forge\"\n     */\n    profile: string;\n    /**\n     * The version of this installation\n     */\n    version: string;\n    /**\n     * The version json path\n     */\n    json: string;\n    /**\n     * The maven artifact name: <org>:<artifact-id>:<version>\n     */\n    path: string;\n    /**\n     * The minecraft version\n     */\n    minecraft: string;\n    /**\n     * The processor shared variables. The key is the name of variable to replace.\n     *\n     * The value of client/server is the value of the variable.\n     */\n    data: {\n        [key: string]: {\n            client: string;\n            server: string;\n        };\n    };\n    /**\n     * The post processor. Which require java to run.\n     */\n    processors: Array<{\n        /**\n         * The executable jar path\n         */\n        jar: string;\n        /**\n         * The classpath to run\n         */\n        classpath: string[];\n        args: string[];\n        outputs?: {\n            [key: string]: string;\n        };\n    }>;\n    /**\n     * The required install profile libraries\n     */\n    libraries: VersionJson.NormalLibrary[];\n}\n/**\n * Default minecraft version manifest url.\n */\nexport declare const DEFAULT_VERSION_MANIFEST_URL = \"https://launchermeta.mojang.com/mc/game/version_manifest.json\";\n/**\n * Default resource/assets url root\n */\nexport declare const DEFAULT_RESOURCE_ROOT_URL = \"https://resources.download.minecraft.net\";\n/**\n * Get and update the version list.\n * This try to send http GET request to offical Minecraft metadata endpoint by default.\n * You can swap the endpoint by passing url on \\`remote\\` in option.\n *\n * @returns The new list if there is\n */\nexport declare function getVersionList(option?: {\n    /**\n     * If this presents, it will send request with the original list timestamp.\n     *\n     * If the server believes there is no modification after the original one,\n     * it will directly return the orignal one.\n     */\n    original?: VersionList;\n    /**\n     * remote url of this request\n     */\n    remote?: string;\n}): Promise<VersionList>;\nexport declare type DownloaderOption = DownloaderOptions;\n/**\n * Change the library host url\n */\nexport interface LibraryOption extends DownloaderOptions {\n    /**\n     * A more flexiable way to control library download url.\n     * @see mavenHost\n     */\n    libraryHost?: LibraryHost;\n    /**\n     * The alterative maven host to download library. It will try to use these host from the \\`[0]\\` to the \\`[maven.length - 1]\\`\n     */\n    mavenHost?: string | string[];\n    /**\n     * Control how many libraries download task should run at the same time.\n     * It will override the \\`maxConcurrencyOption\\` if this is presented.\n     */\n    librariesDownloadConcurrency?: number;\n}\n/**\n * Change the host url of assets download\n */\nexport interface AssetsOption extends DownloaderOptions {\n    /**\n     * The alternative assets host to download asset. It will try to use these host from the \\`[0]\\` to the \\`[assetsHost.length - 1]\\`\n     */\n    assetsHost?: string | string[];\n    /**\n     * Control how many assets download task should run at the same time.\n     * It will override the \\`maxConcurrencyOption\\` if this is presented.\n     */\n    assetsDownloadConcurrency?: number;\n}\n/**\n * Replace the minecraft client or server jar download\n */\nexport interface JarOption extends DownloaderOptions {\n    /**\n     * The client jar url\n     */\n    client?: string;\n    /**\n     * The server jar url\n     */\n    server?: string;\n    /**\n     * The version json url replacement\n     */\n    jsonUrl?: string;\n}\nexport declare type Option = AssetsOption & JarOption & LibraryOption;\ndeclare type RequiredVersion = Pick<Version, \"id\" | \"url\">;\n/**\n * Install the Minecraft game to a location by version metadata.\n *\n * This will install version json, version jar, and all dependencies (assets, libraries)\n *\n * @param type The type of game, client or server\n * @param versionMeta The version metadata\n * @param minecraft The Minecraft location\n * @param option\n */\nexport declare function install(type: \"server\" | \"client\", versionMeta: RequiredVersion, minecraft: MinecraftLocation, option?: Option): Promise<ResolvedVersion>;\n/**\n * Install the Minecraft game to a location by version metadata\n *\n * This will install version json, version jar, and all dependencies (assets, libraries)\n *\n * Tasks emmitted:\n * - install\n *  - installVersion\n *   - json\n *   - jar\n *  - installDependencies\n *   - installAssets\n *     - assetsJson\n *     - asset\n *   - installLibraries\n *     - library\n *\n * @param type The type of game, client or server\n * @param versionMeta The version metadata\n * @param minecraft The Minecraft location\n * @param option\n */\nexport declare function installTask(type: \"server\" | \"client\", versionMeta: RequiredVersion, minecraft: MinecraftLocation, option?: Option): Task<ResolvedVersion>;\n/**\n * Only install the json/jar. Do not install dependencies.\n *\n * @param type client or server\n * @param versionMeta the version metadata; get from updateVersionMeta\n * @param minecraft minecraft location\n */\nexport declare function installVersion(type: \"client\" | \"server\", versionMeta: Version, minecraft: MinecraftLocation, option?: JarOption): Promise<ResolvedVersion>;\n/**\n * Only install the json/jar. Do not check dependencies;\n *\n * Task emmitted:\n * - installVersion\n *   - json\n *   - jar\n *\n * @param type client or server\n * @param versionMeta the version metadata; get from updateVersionMeta\n * @param minecraft minecraft location\n */\nexport declare function installVersionTask(type: \"client\" | \"server\", versionMeta: RequiredVersion, minecraft: MinecraftLocation, options?: JarOption): Task<ResolvedVersion>;\n/**\n * Install the completeness of the Minecraft game assets and libraries on a existed version.\n *\n * @param version The resolved version produced by Version.parse\n * @param minecraft The minecraft location\n */\nexport declare function installDependencies(version: ResolvedVersion, option?: Option): Promise<ResolvedVersion>;\n/**\n * Install the completeness of the Minecraft game assets and libraries.\n *\n * Tasks emitted:\n * - installDependencies\n *  - installAssets\n *   - assetsJson\n *   - asset\n *  - installLibraries\n *   - library\n *\n * @param version The resolved version produced by Version.parse\n * @param minecraft The minecraft location\n */\nexport declare function installDependenciesTask(version: ResolvedVersion, options?: Option): Task<ResolvedVersion>;\n/**\n * Install or check the assets to resolved version\n * @param version The target version\n * @param options The option to replace assets host url\n */\nexport declare function installAssets(version: ResolvedVersion, options?: AssetsOption): Promise<ResolvedVersion>;\n/**\n * Install or check the assets to resolved version\n *\n * Task emitted:\n * - installAssets\n *  - assetsJson\n *  - asset\n *\n * @param version The target version\n * @param options The option to replace assets host url\n */\nexport declare function installAssetsTask(version: ResolvedVersion, options?: AssetsOption): Task<ResolvedVersion>;\n/**\n * Install all the libraries of providing version\n * @param version The target version\n * @param option The library host swap option\n */\nexport declare function installLibraries(version: ResolvedVersion, option?: LibraryOption): Promise<void>;\n/**\n * Install all the libraries of providing version\n *\n * Task emmitted:\n * - installLibraries\n *  - library\n *\n * @param version The target version\n * @param option The library host swap option\n */\nexport declare function installLibrariesTask<T extends Pick<ResolvedVersion, \"minecraftDirectory\" | \"libraries\">>(version: T, option?: LibraryOption): Task<void>;\n/**\n * Only install several resolved assets.\n * @param assets The assets to install\n * @param folder The minecraft folder\n * @param options The asset option\n */\nexport declare function installResolvedAssetsTask(assets: {\n    name: string;\n    hash: string;\n    size: number;\n}[], folder: MinecraftFolder, options?: AssetsOption): Task<void>;\n/**\n * Only install several resolved assets.\n * @param assets The assets to install\n * @param folder The minecraft folder\n * @param options The asset option\n */\nexport declare function installResolvedAssets(assets: {\n    name: string;\n    hash: string;\n    size: number;\n}[], folder: MinecraftFolder, options?: AssetsOption): Promise<void>;\n/**\n * Only install several resolved libraries\n * @param libraries The resolved libraries\n * @param minecraft The minecraft location\n * @param option The install option\n */\nexport declare function installResolvedLibraries(libraries: ResolvedLibrary[], minecraft: MinecraftLocation, option?: LibraryOption): Promise<void>;\n/**\n * Only install several resolved libraries.\n *\n * Task emmitted:\n * - installLibraries\n *  - library\n *\n * @param libraries The resolved libraries\n * @param minecraft The minecraft location\n * @param option The install option\n */\nexport declare function installResolvedLibrariesTask(libraries: ResolvedLibrary[], minecraft: MinecraftLocation, option?: LibraryOption): Task<void>;\nexport interface InstallProfileOption extends LibraryOption {\n    /**\n     * New forge (>=1.13) require java to install. Can be a executor or java executable path.\n     */\n    java?: string;\n    /**\n     * The installation side\n     */\n    side?: \"client\" | \"server\";\n}\n/**\n * Resolve processors in install profile\n */\nexport declare function resolveProcessors(side: \"client\" | \"server\", installProfile: InstallProfile, minecraft: MinecraftFolder): {\n    args: string[];\n    outputs: {\n        [x: string]: string;\n    } | undefined;\n    /**\n     * The executable jar path\n     */\n    jar: string;\n    /**\n     * The classpath to run\n     */\n    classpath: string[];\n}[];\n/**\n * Post process the post processors from \\`InstallProfile\\`.\n *\n * @param processors The processor info\n * @param minecraft The minecraft location\n * @param java The java executable path\n */\nexport declare function postProcess(processors: InstallProfile[\"processors\"], minecraft: MinecraftFolder, java: string): Promise<void>;\n/**\n * Post process the post processors from \\`InstallProfile\\`.\n *\n * @param processors The processor info\n * @param minecraft The minecraft location\n * @param java The java executable path\n */\nexport declare function postProcessTask(processors: InstallProfile[\"processors\"], minecraft: MinecraftFolder, java: string): Task<void>;\n/**\n * Install by install profile. The install profile usually contains some preprocess should run before installing dependencies.\n *\n * @param installProfile The install profile\n * @param minecraft The minecraft location\n * @param options The options to install\n */\nexport declare function installByProfile(installProfile: InstallProfile, minecraft: MinecraftLocation, options?: InstallProfileOption): Promise<void>;\n/**\n * Install by install profile. The install profile usually contains some preprocess should run before installing dependencies.\n *\n * @param installProfile The install profile\n * @param minecraft The minecraft location\n * @param options The options to install\n */\nexport declare function installByProfileTask(installProfile: InstallProfile, minecraft: MinecraftLocation, options?: InstallProfileOption): Task<void>;\n/**\n * Resolve a library download urls with fallback.\n *\n * @param library The resolved library\n * @param libraryOptions The library install options\n */\nexport declare function resolveLibraryDownloadUrls(library: ResolvedLibrary, libraryOptions: LibraryOption): string[];\nexport {};\n`;\nmodule.exports['@xmcl/installer/optifine.d.ts'] = `import { MinecraftLocation, Version } from \"@xmcl/core\";\nimport { Task } from \"@xmcl/task\";\nimport { InstallOptions } from \"./util\";\n/**\n * Generate the optifine version json from provided info.\n * @param editionRelease The edition + release with _\n * @param minecraftVersion The minecraft version\n * @param launchWrapperVersion The launch wrapper version\n * @param options The install options\n * @beta Might be changed and don't break the major version\n */\nexport declare function generateOptifineVersion(editionRelease: string, minecraftVersion: string, launchWrapperVersion: string, options?: InstallOptions): Version;\nexport interface InstallOptifineOptions extends InstallOptions {\n    /**\n     * The java exectable path. It will use \\`java\\` by default.\n     */\n    java?: string;\n}\n/**\n * Install optifine by optifine installer\n *\n * @param installer The installer jar file path\n * @param minecraft The minecraft location\n * @param options The option to install\n * @beta Might be changed and don't break the major version\n */\nexport declare function installByInstaller(installer: string, minecraft: MinecraftLocation, options?: InstallOptifineOptions): Promise<void>;\n/**\n * Install optifine by optifine installer task\n *\n * @param installer The installer jar file path\n * @param minecraft The minecraft location\n * @param options The option to install\n * @beta Might be changed and don't break the major version\n */\nexport declare function installByInstallerTask(installer: string, minecraft: MinecraftLocation, options?: InstallOptifineOptions): Task<void>;\n`;\nmodule.exports['@xmcl/installer/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/installer/util.d.ts'] = `/// <reference types=\"node\" />\nimport { Task } from \"@xmcl/task\";\nimport { ExecOptions } from \"child_process\";\nimport { ReadStream } from \"fs\";\nimport { ProxyStream } from \"got/dist/source/as-stream\";\nexport interface UpdatedObject {\n    timestamp: string;\n}\nexport declare function getRawIfUpdate(url: string, timestamp?: string): Promise<{\n    timestamp: string;\n    content: string | undefined;\n}>;\nexport declare function getIfUpdate<T extends UpdatedObject>(url: string, parser: (s: string) => any, lastObject: T | undefined): Promise<T>;\nexport interface DownloadOption {\n    url: string | string[];\n    retry?: number;\n    method?: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"HEAD\" | \"DELETE\" | \"OPTIONS\" | \"TRACE\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"head\" | \"delete\" | \"options\" | \"trace\";\n    headers?: {\n        [key: string]: string;\n    };\n    timeout?: number;\n    /**\n     * If user wants to know the progress, pass this in, and \\`Downloader\\` should call this when there is a progress.\n     * @param chunkLength The length of just transferred chunk\n     * @param written The chunk already written to the disk\n     * @param total The total bytes of the download file\n     * @param url The remote url of the file\n     */\n    progress?: (chunkLength: number, written: number, total: number, url: string) => boolean | void;\n    /**\n     * If user wants to pause/resume the download, pass this in, and \\`Downloader\\` should call this to tell user how to pause and resume.\n     */\n    pausable?: (pauseFunc: () => void, resumeFunc: () => void) => void;\n    /**\n     * The destination of the download on the disk\n     */\n    destination: string;\n    /**\n     * The checksum info of the file\n     */\n    checksum?: {\n        algorithm: string;\n        hash: string;\n    };\n}\nexport interface Downloader {\n    /**\n     * Download file to the disk\n     *\n     * @returns The downloaded file full path\n     */\n    downloadFile(option: DownloadOption): Promise<void>;\n}\n/**\n * The default downloader based on gotjs\n */\nexport declare class DefaultDownloader implements Downloader {\n    readonly requster: import(\"got/dist/source\").Got;\n    constructor(requster?: import(\"got/dist/source\").Got);\n    protected openDownloadStream(url: string, option: DownloadOption): ReadStream | ProxyStream<unknown>;\n    /**\n     * Download file by the option provided.\n     */\n    downloadFile(option: DownloadOption): Promise<void>;\n}\n/**\n * Wrapped task function of download file if absent task\n */\nexport declare function downloadFileTask(option: DownloadOption, downloaderOptions: HasDownloader<DownloaderOptions>): Task.Function<void>;\nexport declare function spawnProcess(javaPath: string, args: string[], options?: ExecOptions): Promise<void>;\nexport declare function batchedTask(context: Task.Context, tasks: Task<unknown>[], sizes: number[], maxConcurrency?: number, throwErrorImmediately?: boolean, getErrorMessage?: (errors: unknown[]) => string): Promise<void>;\nexport declare function normalizeArray<T>(arr?: T | T[]): T[];\nexport declare function joinUrl(a: string, b: string): string;\n/**\n * Shared install options\n */\nexport interface InstallOptions {\n    /**\n     * When you want to install a version over another one.\n     *\n     * Like, you want to install liteloader over a forge version.\n     * You should fill this with that forge version id.\n     */\n    inheritsFrom?: string;\n    /**\n     * Override the newly installed version id.\n     *\n     * If this is absent, the installed version id will be either generated or provided by installer.\n     */\n    versionId?: string;\n}\nexport declare function normailzeDownloader<T extends {\n    downloader?: Downloader;\n}>(options: T): asserts options is HasDownloader<T>;\nexport declare type HasDownloader<T> = T & {\n    downloader: Downloader;\n};\n/**\n * The collection of errors happened during a parallel process\n */\nexport declare class MultipleError extends Error {\n    errors: unknown[];\n    constructor(errors: unknown[], message?: string);\n}\nexport interface DownloaderOptions {\n    /**\n     * An customized downloader to swap default downloader.\n     */\n    downloader?: Downloader;\n    /**\n     * Decide should downloader redownload and overwrite existed file.\n     *\n     * It has such options:\n     *\n     * - \\`checksumNotMatch\\`: Only the file with checksum provided and not matched will be redownload.\n     * - \\`checksumNotMatchOrEmpty\\`: Not only when the file checksum is not matched, but also when the file has no checksum, the file will be redownloaded.\n     * - \\`always\\`: Always redownload files.\n     *\n     * @default \"checksumNotMatch\"\n     */\n    overwriteWhen?: \"checksumNotMatchOrEmpty\" | \"checksumNotMatch\" | \"always\";\n    /**\n     * Should hault the donwload process immediately after ANY resource download failed.\n     */\n    throwErrorImmediately?: boolean;\n    /**\n     * The max concurrency of the download\n     */\n    maxConcurrency?: number;\n}\n`;\nmodule.exports['@xmcl/mod-parser/fabric.d.ts'] = `import { FileSystem } from \"@xmcl/system\";\ndeclare type Person = {\n    /**\n     * The real name, or username, of the person. Mandatory.\n     */\n    name: string;\n    /**\n     *  Person's contact information. The same as upper level contact. See above. Optional.\n     */\n    contact?: string;\n};\ndeclare type Environment = \"client\" | \"server\" | \"*\";\n/**\n * The \\`ModMetadata\\` is extract from \\`fabric.mod.json\\`.\n *\n * The \\`fabric.mod.json\\` file is a mod metadata file used by Fabric Loader to load mods.\n * In order to be loaded, a mod must have this file with the exact name placed in the root directory of the mod JAR.\n */\nexport interface ModMetadata {\n    /**\n     * Needed for internal mechanisms. Must always be 1.\n     */\n    schemaVersion: number;\n    /**\n     * Defines the mod's identifier - a string of Latin letters, digits, underscores with length from 1 to 63.\n     */\n    id: string;\n    /**\n     * Defines the mod's version - a string value, optionally matching the Semantic Versioning 2.0.0 specification.\n     */\n    version: string;\n    /**\n     * Defines where mod runs: only on the client side (client mod), only on the server side (plugin) or on both sides (regular mod). Contains the environment identifier:\n     * - \\`*\\` Runs everywhere. Default.\n     * - \\`client\\` Runs on the client side.\n     * - \\`server\\` Runs on the server side.\n     */\n    environment?: Environment;\n    /**\n     * Defines main classes of your mod, that will be loaded.\n     * - There are 3 default entry points for your mod:\n     *  - main Will be run first. For classes implementing ModInitializer.\n     *  - client Will be run second and only on the client side. For classes implementing ClientModInitializer.\n     *  - server Will be run second and only on the server side. For classes implementing DedicatedServerModInitializer.\n     * - Each entry point can contain any number of classes to load. Classes (or methods or static fields) could be defined in two ways:\n     *  - If you're using Java, then just list the classes (or else) full names. For example:\n     * \\`\\`\\`json\n     * \"main\": [\n     *      \"net.fabricmc.example.ExampleMod\",\n     *      \"net.fabricmc.example.ExampleMod::handle\"\n     *  ]\n     * \\`\\`\\`\n     *  - If you're using any other language, consult the language adapter's documentation. The Kotlin one is located [here](https://github.com/FabricMC/fabric-language-kotlin/blob/master/README.md).\n     */\n    entrypoints?: string[];\n    /**\n     * A list of nested JARs inside your mod's JAR to load. Before using the field, check out [the guidelines on the usage of the nested JARs](https://fabricmc.net/wiki/tutorial:loader04x#nested_jars). Each entry is an object containing file key. That should be a path inside your mod's JAR to the nested JAR. For example:\n     * \\`\\`\\`json\n     * \"jars\": [\n     *     {\n     *         \"file\": \"nested/vendor/dependency.jar\"\n     *     }\n     * ]\n     * \\`\\`\\`\n     */\n    jars?: string[];\n    /**\n     * A dictionary of adapters for used languages to their adapter classes full names. For example:\n     * \\`\\`\\`json\n     * \"languageAdapters\": {\n     *    \"kotlin\": \"net.fabricmc.language.kotlin.KotlinAdapter\"\n     * }\n     * \\`\\`\\`\n     */\n    languageAdapters?: string[];\n    /**\n     *  A list of mixin configuration files.Each entry is the path to the mixin configuration file inside your mod's JAR or an object containing following fields:\n     *  - \\`config\\` The path to the mixin configuration file inside your mod's JAR.\n     *  - \\`environment\\` The same as upper level \\`environment\\` field.See above. For example:\n     *  \\`\\`\\`json\n     *  \"mixins\": [\n     *       \"modid.mixins.json\",\n     *       {\n     *           \"config\": \"modid.client-mixins.json\",\n     *           \"environment\": \"client\"\n     *       }\n     *   ]\n     *  \\`\\`\\`\n     */\n    mixins?: (string | {\n        config: string;\n        environment: Environment;\n    })[];\n    /**\n     * For dependencies required to run. Without them a game will crash.\n     */\n    depends?: string[] | string;\n    /**\n     * For dependencies not required to run. Without them a game will log a warning.\n     */\n    recommends?: string[] | string;\n    /**\n     * For dependencies not required to run. Use this as a kind of metadata.\n     */\n    suggests?: string[] | string;\n    /**\n     * For mods whose together with yours might cause a game crash. With them a game will crash.\n     */\n    breaks?: string[] | string;\n    /**\n     * For mods whose together with yours cause some kind of bugs, etc. With them a game will log a warning.\n     */\n    conflicts?: string[] | string;\n    /**\n     * Defines the user-friendly mod's name. If not present, assume it matches id.\n     */\n    name?: string;\n    /**\n     * Defines the mod's description. If not present, assume empty string.\n     */\n    description?: string;\n    /**\n     * Defines the contact information for the project. It is an object of the following fields:\n     */\n    contact?: {\n        /**\n         * Contact e-mail pertaining to the mod. Must be a valid e-mail address.\n         */\n        email: string;\n        /**\n         * IRC channel pertaining to the mod. Must be of a valid URL format - for example: irc://irc.esper.net:6667/charset for #charset at EsperNet - the port is optional, and assumed to be 6667 if not present.\n         */\n        irc: string;\n        /**\n         * Project or user homepage. Must be a valid HTTP/HTTPS address.\n         */\n        homepage: string;\n        /**\n         * Project issue tracker. Must be a valid HTTP/HTTPS address.\n         */\n        issues: string;\n        /**\n         * Project source code repository. Must be a valid URL - it can, however, be a specialized URL for a given VCS (such as Git or Mercurial).\n         * The list is not exhaustive - mods may provide additional, non-standard keys (such as discord, slack, twitter, etc) - if possible, they should be valid URLs.\n         */\n        sources: string[];\n    };\n    /**\n     * A list of authors of the mod. Each entry is a single name or an object containing following fields:\n     */\n    authors?: Person[];\n    /**\n     * A list of contributors to the mod. Each entry is the same as in author field. See above.\n     */\n    contributors?: Person[];\n    /**\n     * Defines the licensing information.Can either be a single license string or a list of them.\n     * - This should provide the complete set of preferred licenses conveying the entire mod package.In other words, compliance with all listed licenses should be sufficient for usage, redistribution, etc.of the mod package as a whole.\n     * - For cases where a part of code is dual - licensed, choose the preferred license.The list is not exhaustive, serves primarily as a kind of hint, and does not prevent you from granting additional rights / licenses on a case -by -case basis.\n     * - To aid automated tools, it is recommended to use SPDX License Identifiers for open - source licenses.\n     */\n    license?: string | string[];\n    /**\n     * Defines the mod's icon. Icons are square PNG files. (Minecraft resource packs use 128×128, but that is not a hard requirement - a power of two is, however, recommended.) Can be provided in one of two forms:\n     * - A path to a single PNG file.\n     * - A dictionary of images widths to their files' paths.\n     */\n    icon?: string;\n}\n/**\n * Read fabric mod metadata json from a jar file or a directory\n * @param file The jar file or directory path. I can also be the binary content of the jar if you have already read the jar.\n */\nexport declare function readModMetaData(file: FileSystem | string | Uint8Array): Promise<ModMetadata>;\nexport {};\n`;\nmodule.exports['@xmcl/mod-parser/fabric.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/mod-parser/forge.d.ts'] = `import { FileSystem } from \"@xmcl/system\";\n/**\n * Represent the forge config file\n */\nexport interface Config {\n    [category: string]: {\n        comment?: string;\n        properties: Array<Config.Property<any>>;\n    };\n}\nexport declare namespace Config {\n    type Type = \"I\" | \"D\" | \"S\" | \"B\";\n    interface Property<T = number | boolean | string | number[] | boolean[] | string[]> {\n        readonly type: Type;\n        readonly name: string;\n        readonly comment?: string;\n        value: T;\n    }\n    /**\n     * Convert a forge config to string\n     */\n    function stringify(config: Config): string;\n    /**\n     * Parse a forge config string into \\`Config\\` object\n     * @param body The forge config string\n     */\n    function parse(body: string): Config;\n}\nexport interface ModIndentity {\n    readonly modid: string;\n    readonly version: string;\n}\nexport interface ModMetaData extends ModIndentity {\n    readonly modid: string;\n    readonly name: string;\n    readonly description?: string;\n    readonly version: string;\n    readonly mcversion?: string;\n    readonly acceptedMinecraftVersions?: string;\n    readonly updateJSON?: string;\n    readonly url?: string;\n    readonly logoFile?: string;\n    readonly authorList?: string[];\n    readonly credits?: string;\n    readonly parent?: string;\n    readonly screenShots?: string[];\n    readonly fingerprint?: string;\n    readonly dependencies?: string;\n    readonly accpetRemoteVersions?: string;\n    readonly acceptSaveVersions?: string;\n    readonly isClientOnly?: boolean;\n    readonly isServerOnly?: boolean;\n    /**\n    * Only present in mods.toml\n    */\n    readonly modLoader?: string;\n    /**\n     * Only present in mods.toml\n     * A version range to match for said mod loader - for regular FML @Mod it will be the minecraft version (without the 1.)\n     */\n    readonly loaderVersion?: string;\n    /**\n    * Only present in mods.toml\n    */\n    readonly displayName?: string;\n}\n/**\n * Read metadata of the input mod.\n *\n * This will scan the mcmod.info file, all class file for \\`@Mod\\` & coremod \\`DummyModContainer\\` class.\n * This will also scan the manifest file on \\`META-INF/MANIFEST.MF\\` for tweak mod.\n *\n * @param mod The mod path or data\n */\nexport declare function readModMetaData(mod: Uint8Array | string | FileSystem): Promise<ModMetaData[]>;\n`;\nmodule.exports['@xmcl/mod-parser/forge.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/mod-parser/index.d.ts'] = `import * as Forge from \"./forge\";\nimport * as LiteLoader from \"./liteloader\";\nimport * as Fabric from \"./fabric\";\nexport { Forge, LiteLoader, Fabric };\n`;\nmodule.exports['@xmcl/mod-parser/liteloader.d.ts'] = `import { FileSystem } from \"@xmcl/system\";\nexport declare const DEFAULT_VERSION_MANIFEST = \"http://dl.liteloader.com/versions/versions.json\";\nexport interface MetaData {\n    readonly mcversion: string;\n    readonly name: string;\n    readonly revision: number;\n    readonly author?: string;\n    readonly version?: string;\n    readonly description?: string;\n    readonly url?: string;\n    readonly tweakClass?: string;\n    readonly dependsOn?: string[];\n    readonly injectAt?: string;\n    readonly requiredAPIs?: string[];\n    readonly classTransformerClasses?: string[];\n}\nexport interface VersionMeta {\n    version: string;\n    url: string;\n    file: string;\n    mcversion: string;\n    type: \"RELEASE\" | \"SNAPSHOT\";\n    md5: string;\n    timestamp: string;\n    libraries: Array<{\n        name: string;\n        url?: string;\n    }>;\n    tweakClass: string;\n}\nexport declare function readModMetaData(mod: string | Uint8Array | FileSystem): Promise<MetaData>;\n`;\nmodule.exports['@xmcl/mod-parser/liteloader.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/model/block.d.ts'] = `import { BlockModel, PackMeta } from \"@xmcl/resourcepack\";\nimport { Object3D } from \"three/src/core/Object3D\";\nimport { Vector3 } from \"three/src/math/Vector3\";\ninterface Texture {\n    url: string;\n    animation?: PackMeta.Animation;\n}\ndeclare type TextureRegistry = Record<string, Texture>;\nexport declare const DEFAULT_TRANSFORM: BlockModel.Transform;\nexport declare const DEFAULT_DISPLAY: BlockModel.Display;\nexport declare const BUILTIN_GENERATED: BlockModel.Resolved;\nexport declare class BlockModelObject extends Object3D {\n    animationLoop: boolean;\n    displayOption: BlockModel.Display;\n    applyDisplay(option: string): void;\n    getCenter(): Vector3;\n}\nexport declare class BlockModelFactory {\n    readonly textureRegistry: TextureRegistry;\n    readonly option: {\n        clipUVs?: boolean;\n        modelOnly?: boolean;\n    };\n    private static TRANSPARENT_MATERIAL;\n    private loader;\n    private cachedMaterial;\n    constructor(textureRegistry: TextureRegistry, option?: {\n        clipUVs?: boolean;\n        modelOnly?: boolean;\n    });\n    /**\n     * Get threejs \\`Object3D\\` for that block model.\n     */\n    getObject(model: BlockModel.Resolved): BlockModelObject;\n}\nexport {};\n`;\nmodule.exports['@xmcl/model/index.d.ts'] = `export * from \"./block\";\nexport * from \"./player\";\n`;\nmodule.exports['@xmcl/model/player-model.d.ts'] = `export interface ModelTemplate {\n    head: Part;\n    rightLeg: Part;\n    leftLeg: Part;\n    torso: Part;\n    leftArm: Part;\n    rightArm: Part;\n    cape: Transform & CubeUVMapping;\n}\nexport interface Dimension {\n    h: number;\n    w: number;\n    d: number;\n}\nexport interface CubeUVMapping {\n    top: number[];\n    bottom: number[];\n    right: number[];\n    front: number[];\n    left: number[];\n    back: number[];\n}\nexport interface Translation {\n    x: number;\n    y: number;\n    z: number;\n}\nexport interface Transform extends Translation, Dimension {\n}\nexport interface Part extends Transform, CubeUVMapping {\n    layer: Dimension & CubeUVMapping & Partial<Translation>;\n}\ndeclare const _default: {\n    steve: ModelTemplate;\n    alex: ModelTemplate;\n};\nexport default _default;\n`;\nmodule.exports['@xmcl/model/player.d.ts'] = `import { Object3D } from \"three/src/core/Object3D\";\nimport { MeshBasicMaterial } from \"three/src/materials/MeshBasicMaterial\";\nimport { CanvasTexture } from \"three/src/textures/CanvasTexture\";\ndeclare type TextureSource = string | HTMLImageElement;\nexport declare class PlayerObject3D extends Object3D {\n    private _slim;\n    constructor(skin: MeshBasicMaterial, cape: MeshBasicMaterial, tranparent: MeshBasicMaterial, slim: boolean);\n    get slim(): boolean;\n    set slim(s: boolean);\n}\nexport declare class PlayerModel {\n    static create(): PlayerModel;\n    readonly playerObject3d: PlayerObject3D;\n    readonly materialPlayer: MeshBasicMaterial;\n    readonly materialTransparent: MeshBasicMaterial;\n    readonly materialCape: MeshBasicMaterial;\n    readonly textureCape: CanvasTexture;\n    readonly texturePlayer: CanvasTexture;\n    constructor();\n    setSkin(skin: TextureSource, isSlim?: boolean): Promise<void>;\n    setCape(cape: TextureSource | undefined): Promise<void>;\n}\nexport default PlayerModel;\n`;\nmodule.exports['@xmcl/nbt/index.d.ts'] = `import ByteBuffer from \"bytebuffer\";\ndeclare type Constructor<T> = new (...args: any) => T;\nexport declare const NBTPrototype: unique symbol;\nexport declare const NBTConstructor: unique symbol;\nexport declare type TagType = TagTypePrimitive | typeof TagType.List | typeof TagType.Compound;\nexport declare type TagTypePrimitive = typeof TagType.End | typeof TagType.Byte | typeof TagType.Short | typeof TagType.Int | typeof TagType.Long | typeof TagType.Float | typeof TagType.Double | typeof TagType.ByteArray | typeof TagType.String | typeof TagType.IntArray | typeof TagType.LongArray;\n/**\n * Annotate the type of a field\n */\nexport declare function TagType<T>(type: TagType | Constructor<T> | Schema): (targetClass: any, key: string) => void;\n/**\n * Get NBT schema for this object or a class.\n *\n * If the param is a object, any modifications on this prototype will only affact this object.\n *\n * If the param is a class, any modifications on this prototype will affact all object under this class\n *\n * @param object The object or class\n */\nexport declare function getPrototypeOf(object: object | Function): NBTPrototype;\n/**\n * Set and change the NBT prototype of this object or class\n * @param object A object or a class function\n * @param nbtPrototype The nbt prototype\n */\nexport declare function setPrototypeOf(object: object | Function, nbtPrototype: NBTPrototype): void;\nexport declare namespace TagType {\n    const End: 0;\n    const Byte: 1;\n    const Short: 2;\n    const Int: 3;\n    const Long: 4;\n    const Float: 5;\n    const Double: 6;\n    const ByteArray: 7;\n    const String: 8;\n    const List: 9;\n    const Compound: 10;\n    const IntArray: 11;\n    const LongArray: 12;\n    function getName(tagType: TagType): string;\n}\nexport declare type Schema = ListSchema | CompoundSchema | Constructor<any>;\nexport declare type ListSchema = [TagType | Schema];\nexport declare type CompoundSchema = {\n    [key: string]: TagType | Schema;\n};\nexport interface NBTPrototype extends CompoundSchema {\n    [NBTConstructor]: () => any;\n}\nexport interface IO {\n    read(buf: ByteBuffer, context: ReadContext): any;\n    write(buf: ByteBuffer, value: any, context: WriteContext): void;\n}\nexport interface SerializationOption {\n    compressed?: true | \"deflate\" | \"gzip\";\n    /**\n     * IO override for serialization\n     */\n    io?: {\n        [tagType: number]: IO;\n    };\n    /**\n     * Used for serialize function. Assign the filename for it.\n     */\n    filename?: string;\n}\nexport interface DeserializationOption<T> {\n    compressed?: true | \"deflate\" | \"gzip\";\n    /**\n     * IO override for serialization\n     */\n    io?: {\n        [tagType: number]: IO;\n    };\n    type?: Constructor<T>;\n}\n/**\n * Serialzie an nbt typed json object into NBT binary\n * @param object The json\n * @param compressed Should we compress it\n */\nexport declare function serialize(object: object, option?: SerializationOption): Promise<Uint8Array>;\n/**\n * Deserialize the nbt binary into json\n * @param fileData The nbt binary\n */\nexport declare function deserialize<T>(fileData: Uint8Array, option?: DeserializationOption<T>): Promise<T>;\n/**\n * Serialzie an nbt typed json object into NBT binary\n * @param object The json\n */\nexport declare function serializeSync(object: object, option?: SerializationOption): Uint8Array;\n/**\n * Deserialize the nbt binary into json\n * @param fileData The nbt binary\n * @param compressed Should we compress it\n */\nexport declare function deserializeSync<T>(fileData: Uint8Array, option?: DeserializationOption<T>): T;\nexport declare class ReadContext {\n    schema: Schema | undefined;\n    tagType: TagType;\n    inspect: Schema | undefined;\n    constructor(schema: Schema | undefined, tagType: TagType);\n    fork(schemaOrTagType: TagType | Schema): ReadContext;\n}\nexport declare class WriteContext {\n    readonly schema: Schema | undefined;\n    readonly tagType: TagType;\n    constructor(schema: Schema | undefined, tagType: TagType);\n    fork(schemaOrTagType: TagType | Schema): WriteContext;\n}\nexport {};\n`;\nmodule.exports['@xmcl/nbt/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/nbt/utils.d.ts'] = `/// <reference types=\"bytebuffer\" />\nexport declare function writeUTF8(out: ByteBuffer, str: string): number;\nexport declare function readUTF8(buff: ByteBuffer): string;\n`;\nmodule.exports['@xmcl/nbt/zlib/index.browser.d.ts'] = `export declare function gzip(buffer: Uint8Array): Promise<Uint8Array>;\nexport declare function gzipSync(buffer: Uint8Array): Uint8Array;\nexport declare function ungzip(buffer: Uint8Array): Promise<Uint8Array>;\nexport declare function gunzipSync(buffer: Uint8Array): Uint8Array;\nexport declare function inflate(buffer: Uint8Array): Promise<Uint8Array>;\nexport declare function deflate(buffer: Uint8Array): Promise<Uint8Array>;\nexport declare function inflateSync(buffer: Uint8Array): Uint8Array;\nexport declare function deflateSync(buffer: Uint8Array): Uint8Array;\n`;\nmodule.exports['@xmcl/nbt/zlib/index.d.ts'] = `import { deflateSync, gunzipSync, gzipSync, inflateSync } from \"zlib\";\nexport declare const gzip: (buf: Uint8Array) => Promise<Uint8Array>;\nexport declare const ungzip: (buf: Uint8Array) => Promise<Uint8Array>;\nexport declare const inflate: (buf: Uint8Array) => Promise<Uint8Array>;\nexport declare const deflate: (buf: Uint8Array) => Promise<Uint8Array>;\nexport { gzipSync, gunzipSync, inflateSync, deflateSync };\n`;\nmodule.exports['@xmcl/resource-manager/index.d.ts'] = `import { PackMeta, ResourcePack, Resource, ResourceLocation } from \"@xmcl/resourcepack\";\ninterface ResourceSourceWrapper {\n    source: ResourcePack;\n    info: PackMeta.Pack;\n    domains: string[];\n}\n/**\n * The resource manager just like Minecraft. Design to be able to use in both nodejs and browser environment.\n */\nexport declare class ResourceManager {\n    private list;\n    get allResourcePacks(): PackMeta.Pack[];\n    private cache;\n    constructor(list?: Array<ResourceSourceWrapper>);\n    /**\n     * Add a new resource source to the end of the resource list.\n     */\n    addResourcePack(resourcePack: ResourcePack): Promise<void>;\n    /**\n     * Clear all cache\n     */\n    clearCache(): void;\n    /**\n     * Clear all resource source and cache\n     */\n    clearAll(): void;\n    /**\n     * Swap the resource source priority.\n     */\n    swap(first: number, second: number): void;\n    /**\n     * Invalidate the resource cache\n     */\n    invalidate(location: ResourceLocation): void;\n    load(location: ResourceLocation): Promise<Resource | undefined>;\n    load(location: ResourceLocation, urlOnly: false): Promise<Resource | undefined>;\n    load(location: ResourceLocation, urlOnly: true): Promise<Resource | undefined>;\n    private putCache;\n}\nexport * from \"./model-loader\";\n`;\nmodule.exports['@xmcl/resource-manager/model-loader.d.ts'] = `import { BlockModel, Resource } from \"@xmcl/resourcepack\";\nimport { ResourceManager } from \"./index\";\n/**\n * The model loader load the resource\n */\nexport declare class ModelLoader {\n    readonly manager: ResourceManager;\n    static findRealTexturePath(model: BlockModel.Resolved, variantKey: string): string | undefined;\n    /**\n     * All required texture raw resources\n     */\n    readonly textures: Record<string, Resource>;\n    /**\n     * All the resolved model\n     */\n    readonly models: Record<string, BlockModel.Resolved>;\n    /**\n     * @param manager The resource manager\n     */\n    constructor(manager: ResourceManager);\n    /**\n     * Load a model by search its parent. It will throw an error if the model is not found.\n     */\n    loadModel(modelPath: string): Promise<BlockModel.Resolved>;\n}\n`;\nmodule.exports['@xmcl/resource-manager/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/resourcepack/format.d.ts'] = `/**\n * The pack meta json format\n */\nexport interface PackMeta {\n    texture?: PackMeta.Texture;\n    animation?: PackMeta.Animation;\n    pack?: PackMeta.Pack;\n    language: PackMeta.Language;\n}\n/**\n * The block model json format\n */\nexport interface BlockModel {\n    /**\n     * For Block:\n     *\n     * Loads a different model from the given path, starting in assets/minecraft/models. If both \"parent\" and \"elements\" are set, the \"elements\" tag overrides the \"elements\" tag from the previous model.\n     * Can be set to \"builtin/generated\" to use a model that is created out of the specified icon. Note that only the first layer is supported, and rotation can only be achieved using block states files.\n     *\n     * For Item:\n     *\n     * Loads a different model from the given path, starting in assets/minecraft/models. If both \"parent\" and \"elements\" are set, the \"elements\" tag overrides the \"elements\" tag from the previous model.\n     * Can be set to \"builtin/generated\" to use a model that is created out of the specified icon.\n     * Can be set to \"builtin/entity\" to load a model from an entity file. As you can not specify the entity, this does not work for all items (only for chests, ender chests, mob heads, shields and banners).\n     * Needs to be set to \"builtin/compass\" or \"builtin/clock\" for the compass and the clock.\n     */\n    parent?: string;\n    ambientocclusion?: boolean;\n    /**\n     * Holds the different places where item models are displayed.\n     */\n    display?: BlockModel.Display;\n    /**\n     * Holds the textures of the model. Each texture starts in assets/minecraft/textures or can be another texture variable.\n     */\n    textures?: {\n        /**\n         * What texture to load particles from. This texture is used if you are in a nether portal. Note: All breaking particles from non-model blocks are hard-coded.\n         */\n        particle?: string;\n        [variant: string]: string | undefined;\n    };\n    /**\n     * Contains all the elements of the model. they can only have cubic forms. If both \"parent\" and \"elements\" are set, the \"elements\" tag overrides the \"elements\" tag from the previous model.\n     */\n    elements?: BlockModel.Element[];\n    /**\n     * Determines cases which a different model should be used based on item tags.\n     * All cases are evaluated in order from top to bottom and last predicate that mathches will override.\n     * However, overrides are ignored if it has been already overriden once, for example this avoids recursion on overriding to the same model.\n     */\n    overrides?: Array<{\n        /**\n         * predicate: Holds the cases.\n         */\n        prediction: {\n            [attribute: string]: number;\n        };\n        /**\n         * The path to the model to use if the case is met, starting in assets/minecraft/models/\n         */\n        model: string;\n    }>;\n}\nexport declare namespace PackMeta {\n    interface Language {\n        /**\n         * Language code for a language, corresponding to a .json file with the same name in the folder assets/<namespace>/lang.\n         */\n        [lang: string]: {\n            /**\n             * The full name of the language\n             */\n            name: string;\n            /**\n             * The country or region name\n             */\n            region: string;\n            /**\n             * If true, the language reads right to left.\n             */\n            bidirectional: boolean;\n        };\n    }\n    /**\n     * Holds the resource pack information\n     */\n    interface Pack {\n        /**\n         * Pack version. If this number does not match the current required number, the resource pack will display an error and required additional confirmation to load the pack.\n         * Requires 1 for 1.6.1–1.8.9, 2 for 1.9–1.10.2, 3 for 1.11–1.12.2, and 4 for 1.13–1.14.4.\n         */\n        pack_format: number;\n        /**\n         * Text that will be shown below the pack name in the resource pack menu.\n         * The text will be shown on two lines. If the text is too long it will be cut off.\n         *\n         * Contains a raw JSON text object that will be shown instead as the pack description in the resource pack menu.\n         * Same behavior as the string version of the description tag, but they cannot exist together.[\n         */\n        description: string | object;\n    }\n    interface Animation {\n        /**\n         * If true, Minecraft will generate additional frames between frames with a frame time greater than 1 between them. Defaults to false.\n         */\n        interpolate: boolean;\n        /**\n         * The width of the tile, as a direct ratio rather than in pixels. This is unused in vanilla but can be used by mods to have frames that are not perfect squares.\n         */\n        width: number;\n        /**\n         * The height of the tile in direct pixels, as a ratio rather than in pixels. This is unused in vanilla but can be used by mods to have frames that are not perfect squares.\n         */\n        height: number;\n        /**\n         * Sets the default time for each frame in increments of one game tick. Defaults to \\`1\\`.\n         */\n        frametime: number;\n        frames: Array<{\n            index: number;\n            time: number;\n        }>;\n    }\n    interface Texture {\n        /**\n         * Causes the texture to blur when viewed from close up. Defaults to \\`false\\`\n         */\n        blur: boolean;\n        /**\n         * Causes the texture to stretch instead of tiling in cases where it otherwise would, such as on the shadow. Defaults to \\`false\\`\n         */\n        clamp: boolean;\n        /**\n         * Custom mipmap values for the texture\n         */\n        mipmaps: string[];\n    }\n}\ndeclare type Vec3 = [number, number, number];\ndeclare type Vec4 = [number, number, number, number];\nexport declare namespace BlockModel {\n    type Direction = \"up\" | \"down\" | \"north\" | \"south\" | \"west\" | \"east\";\n    interface Display {\n        thirdperson_righthand: Transform;\n        thirdperson_lefthand: Transform;\n        firstperson_righthand: Transform;\n        firstperson_lefthand: Transform;\n        gui: Transform;\n        head: Transform;\n        ground: Transform;\n        fixed: Transform;\n    }\n    interface Element {\n        /**\n         * Start point of a cube according to the scheme [x, y, z]. Values must be between -16 and 32.\n         */\n        from: Vec3;\n        /**\n         * Stop point of a cube according to the scheme [x, y, z]. Values must be between -16 and 32.\n         */\n        to: Vec3;\n        /**\n         * Defines the rotation of an element.\n         */\n        rotation?: {\n            /**\n             * Sets the center of the rotation according to the scheme [x, y, z], defaults to [8, 8, 8].\n             */\n            origin: Vec3;\n            /**\n             * Specifies the direction of rotation, can be \"x\", \"y\" or \"z\".\n             */\n            axis: \"x\" | \"y\" | \"z\";\n            /**\n             * Specifies the angle of rotation. Can be 45 through -45 degrees in 22.5 degree increments. Defaults to 0.\n             */\n            angle: number;\n            /**\n             * Specifies whether or not to scale the faces across the whole block. Can be true or false. Defaults to false.\n             */\n            rescale: boolean;\n        };\n        /**\n         * Defines if shadows are rendered (true - default), not (false).\n         */\n        shade?: boolean;\n        faces?: {\n            up?: Face;\n            down?: Face;\n            north?: Face;\n            south?: Face;\n            east?: Face;\n            west?: Face;\n        };\n    }\n    interface Face {\n        /**\n         * Defines the area of the texture to use according to the scheme [x1, y1, x2, y2].\n         * If unset, it defaults to values equal to xyz position of the element.\n         * The texture behavior will be inconsistent if UV extends below 0 or above 16.\n         * If the numbers of x1 and x2 are swapped (e.g. from 0, 0, 16, 16 to 16, 0, 0, 16), the texture will be flipped. UV is optional, and if not supplied it will automatically generate based on the element's position.\n         */\n        uv?: Vec4;\n        /**\n         * Specifies the texture in form of the texture variable prepended with a #.\n         */\n        texture: string;\n        /**\n         * Specifies whether a face does not need to be rendered when there is a block touching it in the specified position.\n         * The position can be: down, up, north, south, west, or east. It will also determine which side of the block to use the light level from for lighting the face,\n         * and if unset, defaults to the side.\n         */\n        cullface?: Direction;\n        /**\n         * Rotates the texture by the specified number of degrees.\n         * Can be 0, 90, 180, or 270. Defaults to 0. Rotation does not affect which part of the texture is used.\n         * Instead, it amounts to permutation of the selected texture vertexes (selected implicitly, or explicitly though uv).\n         */\n        rotation?: 0 | 90 | 180 | 270;\n        /**\n         * Determines whether to tint the texture using a hardcoded tint index. The default is not using the tint, and any number causes it to use tint. Note that only certain blocks have a tint index, all others will be unaffected.\n         */\n        tintindex?: number;\n    }\n    interface Transform {\n        /**\n         * Specifies the rotation of the model according to the scheme [x, y, z].\n         */\n        rotation: Vec3;\n        /**\n         *  Specifies the position of the model according to the scheme [x, y, z]. If the value is greater than 80, it is displayed as 80. If the value is less then -80, it is displayed as -80.\n         */\n        translation: Vec3;\n        /**\n         * Specifies the scale of the model according to the scheme [x, y, z]. If the value is greater than 4, it is displayed as 4.\n         */\n        scale: Vec3;\n    }\n    type Resolved = Omit<Required<BlockModel>, \"parent\" | \"override\" | \"elements\"> & {\n        overrides?: BlockModel[\"overrides\"];\n        elements: Array<Omit<Element, \"faces\"> & {\n            faces: {\n                up?: Face;\n                down?: Face;\n                north?: Face;\n                south?: Face;\n                east?: Face;\n                west?: Face;\n            };\n        }>;\n    };\n}\nexport {};\n`;\nmodule.exports['@xmcl/resourcepack/index.d.ts'] = `import { FileSystem } from \"@xmcl/system\";\nimport { PackMeta } from \"./format\";\nexport declare class ResourceLocation {\n    readonly domain: string;\n    readonly path: string;\n    /**\n     * build from texture path\n     */\n    static ofTexturePath(path: string): ResourceLocation;\n    /**\n     * build from model path\n     */\n    static ofModelPath(path: string): ResourceLocation;\n    /**\n     * from absoluted path\n     */\n    static fromPath(path: string): ResourceLocation;\n    static getAssetsPath(location: ResourceLocation): string;\n    constructor(domain: string, path: string);\n    toString(): string;\n}\nexport interface Resource<T = Uint8Array> {\n    /**\n     * the absolute location of the resource\n     */\n    location: ResourceLocation;\n    /**\n     * The real resource url;\n     */\n    url: string;\n    /**\n     * The resource content\n     */\n    content: T;\n    /**\n     * The metadata of the resource\n     */\n    metadata: PackMeta;\n}\nexport declare class ResourcePack {\n    private fs;\n    constructor(fs: FileSystem);\n    /**\n     * Load the resource\n     * @param location The resource location\n     * @param urlOnly Should only provide the url, no content\n     */\n    load(location: ResourceLocation, urlOnly: boolean): Promise<Resource | void>;\n    /**\n     * Does the resource source has the resource\n     */\n    has(location: ResourceLocation): Promise<boolean>;\n    /**\n     * The owned domain. You can think about the modids.\n     */\n    domains(): Promise<string[]>;\n    /**\n     * The pack info, just like resource pack\n     */\n    info(): Promise<PackMeta.Pack>;\n    /**\n     * The icon of the resource pack\n     */\n    icon(): Promise<Uint8Array>;\n    private getPath;\n    static open(resourcePack: string | Uint8Array | FileSystem): Promise<ResourcePack>;\n}\nexport * from \"./format\";\n/**\n * Read the resource pack metadata from zip file or directory.\n *\n * If you have already read the data of the zip file, you can pass it as the second parameter. The second parameter will be ignored on reading directory.\n *\n * @param resourcePack The absolute path of the resource pack file, or a buffer, or a opened resource pack.\n */\nexport declare function readPackMeta(resourcePack: string | Uint8Array | FileSystem): Promise<PackMeta.Pack>;\n/**\n * Read the resource pack icon png binary.\n * @param resourcePack The absolute path of the resource pack file, or a buffer, or a opened resource pack.\n */\nexport declare function readIcon(resourcePack: string | Uint8Array | FileSystem): Promise<Uint8Array>;\n/**\n * Read both metadata and icon\n */\nexport declare function readPackMetaAndIcon(resourcePack: string | Uint8Array | FileSystem): Promise<{\n    metadata: PackMeta.Pack;\n    icon: Uint8Array | undefined;\n}>;\n`;\nmodule.exports['@xmcl/resourcepack/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/server-info/index.d.ts'] = `export declare class ServerInfo {\n    icon: string;\n    ip: string;\n    name: string;\n    acceptTextures: number;\n}\n/**\n * The servers.dat format server information, contains known host displayed in \"Multipler\" page.\n */\nexport declare class ServersData {\n    servers: ServerInfo[];\n}\n/**\n * Read the server information from the binary data of .minecraft/server.dat file, which stores the local known server host information.\n *\n * @param buff The binary data of .minecraft/server.dat\n */\nexport declare function readInfo(buff: Uint8Array): Promise<ServerInfo[]>;\n/**\n * Write the information to NBT format used by .minecraft/server.dat file.\n *\n * @param infos The array of server information.\n */\nexport declare function writeInfo(infos: ServerInfo[]): Promise<Uint8Array>;\n/**\n * Read the server information from the binary data of .minecraft/server.dat file, which stores the local known server host information.\n *\n * @param buff The binary data of .minecraft/server.dat\n */\nexport declare function readInfoSync(buff: Uint8Array): ServerInfo[];\n/**\n * Write the information to NBT format used by .minecraft/server.dat file.\n *\n * @param infos The array of server information.\n */\nexport declare function writeInfoSync(infos: ServerInfo[]): Uint8Array;\n`;\nmodule.exports['@xmcl/server-info/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/system/index.browser.d.ts'] = `export * from \"./system\";\n`;\nmodule.exports['@xmcl/system/index.d.ts'] = `export * from \"./system\";\n`;\nmodule.exports['@xmcl/system/system.d.ts'] = `export interface System {\n    fs: FileSystem;\n    openFileSystem(basePath: string | Uint8Array): Promise<FileSystem>;\n    resolveFileSystem(base: string | Uint8Array | FileSystem): Promise<FileSystem>;\n    decodeBase64(input: string): string;\n    encodeBase64(input: string): string;\n    bufferToText(buff: Uint8Array): string;\n    bufferToBase64(buff: Uint8Array): string;\n}\nexport declare abstract class FileSystem {\n    abstract readonly root: string;\n    abstract readonly sep: string;\n    abstract readonly type: \"zip\" | \"path\";\n    abstract readonly writeable: boolean;\n    abstract join(...paths: string[]): string;\n    abstract isDirectory(name: string): Promise<boolean>;\n    abstract existsFile(name: string): Promise<boolean>;\n    abstract readFile(name: string, encoding: \"utf-8\" | \"base64\"): Promise<string>;\n    abstract readFile(name: string): Promise<Uint8Array>;\n    abstract readFile(name: string, encoding?: \"utf-8\" | \"base64\"): Promise<Uint8Array | string>;\n    abstract listFiles(name: string): Promise<string[]>;\n    missingFile(name: string): Promise<boolean>;\n    walkFiles(target: string, walker: (path: string) => void | Promise<void>): Promise<void>;\n}\nexport declare let System: System;\nexport declare function setSystem(sys: System): void;\n`;\nmodule.exports['@xmcl/system/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/task/index.d.ts'] = `/// <reference types=\"node\" />\nimport { EventEmitter } from \"events\";\nexport declare type TaskNode = Task.State;\nexport interface TaskListener<N extends Task.State = Task.State> extends EventEmitter {\n    /**\n     * Emitted when the some task starts to execute. The listener will get both this task state and parent task state.\n     *\n     * If there is no parent, it will be undefined.\n     */\n    on(event: \"execute\", listener: (node: N, parent?: N) => void): this;\n    /**\n     * Emitted when the some task failed.\n     */\n    on(event: \"fail\", listener: (error: any, node: N) => void): this;\n    /**\n     * Emitted when the task has update.\n     *\n     * The progress and total are arbitary number which designed by task creator.\n     * You might want to convert them to percentage by yourself by directly dividing them.\n     *\n     * The message is a totally optional and arbitary string for hint.\n     */\n    on(event: \"update\", listener: (update: {\n        progress: number;\n        total?: number;\n        message?: string;\n    }, node: N) => void): this;\n    /**\n     * Emitted the when some task is finished\n     */\n    on(event: \"finish\", listener: (result: any, node: N) => void): this;\n    /**\n     * Emitted the pause event after user toggle the \\`pause\\` in handle\n     */\n    on(event: \"pause\", listener: (node: N) => void): this;\n    /**\n     * Emitted the resume event after use toggle the \\`resume\\` in handle\n     */\n    on(event: \"resume\", listener: (node: N) => void): this;\n    /**\n     * Emitted the cancel event after some task is cancelled.\n     */\n    on(event: \"cancel\", listener: (node: N) => void): this;\n    once(event: \"execute\", listener: (node: N, parent?: N) => void): this;\n    once(event: \"fail\", listener: (error: any, node: N) => void): this;\n    once(event: \"update\", listener: (update: {\n        progress: number;\n        total?: number;\n        message?: string;\n    }, node: N) => void): this;\n    once(event: \"finish\", listener: (result: any, node: N) => void): this;\n    once(event: \"pause\", listener: (node: N) => void): this;\n    once(event: \"resume\", listener: (node: N) => void): this;\n    once(event: \"cancel\", listener: (node: N) => void): this;\n}\n/**\n * An intergrated environment to run the task. If you want to manage all your tasks together, you should use this.\n */\nexport declare class TaskRuntime<N extends Task.State = Task.State> extends EventEmitter implements TaskListener<N> {\n    readonly factory: Task.StateFactory<N>;\n    protected bridge: TaskBridge<N>;\n    constructor(factory: Task.StateFactory<N>, schedular: Task.Schedualer);\n    /**\n     * Emitted when the some task starts to execute. The listener will get both this task state and parent task state.\n     *\n     * If there is no parent, it will be undefined.\n     */\n    on(event: \"execute\", listener: (node: N, parent?: N) => void): this;\n    /**\n     * Emitted when the task has update.\n     *\n     * The progress and total are arbitary number which designed by task creator.\n     * You might want to convert them to percentage by yourself by directly dividing them.\n     *\n     * The message is a totally optional and arbitary string for hint.\n     */\n    on(event: \"update\", listener: (update: {\n        progress: number;\n        total?: number;\n        message?: string;\n    }, node: N) => void): this;\n    /**\n     * Emitted the when some task is finished\n     */\n    on(event: \"finish\", listener: (result: any, node: N) => void): this;\n    /**\n     * Emitted when the some task failed.\n     */\n    on(event: \"fail\", listener: (error: any, node: N) => void): this;\n    /**\n     * Emitted the pause event after user toggle the \\`pause\\` in handle\n     */\n    on(event: \"pause\", listener: (node: N) => void): this;\n    /**\n     * Emitted the resume event after use toggle the \\`resume\\` in handle\n     */\n    on(event: \"resume\", listener: (node: N) => void): this;\n    /**\n     * Emitted the cancel event after some task is cancelled.\n     */\n    on(event: \"cancel\", listener: (node: N) => void): this;\n    once(event: \"execute\", listener: (node: N, parent?: N) => void): this;\n    once(event: \"fail\", listener: (error: any, node: N) => void): this;\n    once(event: \"update\", listener: (update: {\n        progress: number;\n        total?: number;\n        message?: string;\n    }, node: N) => void): this;\n    once(event: \"finish\", listener: (result: any, node: N) => void): this;\n    once(event: \"pause\", listener: (node: N) => void): this;\n    once(event: \"resume\", listener: (node: N) => void): this;\n    once(event: \"cancel\", listener: (node: N) => void): this;\n    submit<T>(task: Task<T>): TaskHandle<T, N>;\n}\nexport declare class TaskSignal {\n    _paused: boolean;\n    _cancelled: boolean;\n    _started: boolean;\n    _resumePauseCallback: null | (() => void);\n    _onPause: null | (() => void);\n    _onResume: null | (() => void);\n}\nexport declare class TaskBridge<X extends Task.State = Task.State> {\n    readonly emitter: EventEmitter;\n    readonly factory: Task.StateFactory<X>;\n    readonly scheduler: <N>(r: () => Promise<N>) => Promise<N>;\n    constructor(emitter: EventEmitter, factory: Task.StateFactory<X>, scheduler: <N>(r: () => Promise<N>) => Promise<N>);\n    submit<T>(task: Task<T>): TaskHandle<T, X>;\n    protected enqueueTask<T>(signal: TaskSignal, task: Task<T>, parent?: {\n        node: X;\n        progressUpdate: (progress: number, total: number, message?: string) => void;\n    }): {\n        node: X;\n        promise: Promise<T>;\n    };\n}\nexport interface TaskHandle<T, N extends Task.State> {\n    /**\n     * Wait the task to complete\n     */\n    wait(): Promise<T>;\n    /**\n     * Cancel the task.\n     */\n    cancel(): void;\n    /**\n     * Pause the task if possible.\n     */\n    pause(): void;\n    resume(): void;\n    readonly root: N;\n    readonly isCancelled: boolean;\n    readonly isPaused: boolean;\n    readonly isStarted: boolean;\n}\nexport declare class Task<T> {\n    readonly name: string;\n    readonly parameters: object | undefined;\n    readonly run: (context: Task.Context) => (Promise<T> | T);\n    constructor(name: string, parameters: object | undefined, run: (context: Task.Context) => (Promise<T> | T));\n    /**\n     * Execute this task immediately (not in runtime).\n     * This will have the same behavior like \\`Task.execute\\`.\n     *\n     * @see Task.execute\n     */\n    execute(): TaskHandle<T, Task.State> & TaskListener<Task.State>;\n}\nexport declare namespace Task {\n    interface Function<T> {\n        (context: Task.Context): (Promise<T> | T);\n    }\n    interface Object<T> {\n        readonly name: string;\n        readonly parameters?: object;\n        readonly run: (context: Task.Context) => (Promise<T> | T);\n    }\n    /**\n     * You'll recive this if the task is cancelled.\n     */\n    class CancelledError extends Error {\n        constructor();\n    }\n    type Schedualer = <N>(r: () => Promise<N>) => Promise<N>;\n    interface Context {\n        pausealbe(onPause?: () => void, onResume?: () => void): void;\n        update(progres: number, total?: number, message?: string): void | boolean;\n        execute<T>(task: Task<T>, pushProgress?: number): Promise<T>;\n    }\n    type StateFactory<X extends Task.State = Task.State> = (node: Task.State, parent?: X) => X;\n    const DEFAULT_STATE_FACTORY: StateFactory;\n    /**\n     * Run the task immediately without a integrated runtime\n     * @param task The task will be run\n     */\n    function execute<T>(task: Task<T>): TaskHandle<T, Task.State> & TaskListener;\n    /**\n     * Create a central managed runtime for task execution. You can listen the tasks status at one place.\n     * @param factory The state factory. It's used to customize your task state.\n     * @param schedular The task schedular provided\n     */\n    function createRuntime<X extends Task.State = Task.State>(factory?: StateFactory<X>, schedular?: Schedualer): TaskRuntime<X>;\n    interface State {\n        name: string;\n        arguments?: {\n            [key: string]: any;\n        };\n        path: string;\n    }\n    function create<T>(name: string, task: Task.Function<T>, parameters?: any): Task<T>;\n}\n/**\n * Create new task\n */\nexport declare function task<T>(name: string, task: Task.Function<T>, parameters?: any): Task<T>;\n`;\nmodule.exports['@xmcl/task/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/text-component/index.d.ts'] = `/**\n * @see https://minecraft.gamepedia.com/Raw_JSON_text_format\n */\nexport interface TextComponent {\n    /**\n     * A string representing raw text to display directly in chat. Note that selectors such as \"@a\" and \"@p\" are not translated into player names; use selector instead. Can use escape characters, such as \\n for newline (enter), \\t for tab, etc.\n     */\n    text: string;\n    /**\n     * The translation identifier of text to be displayed using the player's selected language. This identifier is the same as the identifiers found in lang files from assets or resource packs. Ignored when  text exist in the root object.\n     */\n    translate?: string;\n    /**\n     * A list of chat component arguments and/or string arguments to be used by translate. Useless otherwise.\n     *\n     * The arguments are text corresponding to the arguments used by the translation string in the current language, in order (for example, the first list element corresponds to \"%1\\$s\" in a translation string). Argument structure repeats this raw JSON text structure.\n     */\n    with?: string[];\n    /**\n     * A player's score in an objective. Displays nothing if the player is not tracked in the given objective.\n     * Ignored when any of the previous fields exist in the root object.\n     */\n    score?: {\n        name: string;\n        objective: string;\n        value: string;\n    };\n    /**\n     * A string containing a selector (@p,@a,@r,@e or @s) and, optionally, selector arguments.\n     *\n     * Unlike text, the selector is translated into the correct player/entity names.\n     * If more than one player/entity is detected by the selector, it is displayed in a form such as 'Name1 and Name2' or 'Name1, Name2, Name3, and Name4'.\n     * Ignored when any of the previous fields exist in the root object.\n     *\n     * - Clicking a player's name inserted into a /tellraw command this way suggests a command to whisper to that player.\n     * - Shift-clicking a player's name inserts that name into chat.\n     * - Shift-clicking a non-player entity's name inserts its UUID into chat.\n     */\n    selector?: string;\n    /**\n     * A string that can be used to display the key needed to preform a certain action.\n     * An example is \\`key.inventory\\` which always displays \"E\" unless the player has set a different key for opening their inventory.\n     *\n     * Ignored when any of the previous fields exist in the root object.\n     */\n    keybind?: string;\n    /**\n     *  A string indicating the NBT path used for looking up NBT values from an entity or a block entity. Ignored when any of the previous fields exist in the root object.\n     */\n    nbt?: string;\n    /**\n     * A string specifying the coordinates of the block entity from which the NBT value is obtained. The coordinates can be absolute or relative. Useless if  nbt is absent.\n     */\n    block?: string;\n    /**\n     * A string specifying the target selector for the entity from which the NBT value is obtained. Useless if  nbt is absent.\n     */\n    entity?: string;\n    /**\n     * A list element whose structure repeats this raw JSON text structure. Note that all properties of this object are inherited by children except for text, extra, translate, with, and score.\n     *\n     * This means that children retain the same formatting and events as this object unless they explicitly override them.\n     */\n    extra?: TextComponent[];\n    /**\n     * The color to render this text in. Valid values are \"black\", \"dark_blue\", \"dark_green\", \"dark_aqua\", \"dark_red\", \"dark_purple\", \"gold\", \"gray\", \"dark_gray\", \"blue\", \"green\", \"aqua\", \"red\", \"light_purple\", \"yellow\", \"white\", and \"reset\" (cancels out the effects of colors used by parent objects). Technically, \"bold\", \"italic\", \"underlined\", \"strikethrough\", and \"obfuscated\" are also accepted, but it may be better practice to use the tags below for such formats.\n     */\n    color?: string;\n    bold?: boolean;\n    italic?: boolean;\n    underlined?: boolean;\n    strikethrough?: boolean;\n    obfuscated?: boolean;\n    /**\n     * When the text is shift-clicked by a player, this string is inserted in their chat input. It does not overwrite any existing text the player was writing.\n     */\n    insertion?: string;\n    /**\n     *  Allows for events to occur when the player clicks on text.\n     */\n    clickEvent?: {\n        /**\n         * The action to perform when clicked.\n         * Valid values are\n         * - \"open_url\" (opens value as a URL in the player's default web browser),\n         * - \"open_file\" (opens the value file on the user's computer),\n         * - \"run_command\" (has value entered in chat as though the player typed it themselves. This can be used to run commands, provided the player has the required permissions),\n         * - \"change_page\" (can be used only in written books) changes to page value if that page exists,\n         * - \"suggest_command\" (similar to \"run_command\" but it cannot be used in a written book, the text appears only in the player's chat input and it is not automatically entered. Unlike insertion, this replaces the existing contents of the chat input),\n         * - \"copy_to_clipboard\"‌[upcoming: 1.15] (copy the value to the clipboard). \"open_file\" is used in messages automatically generated by the game (e.g. on taking a screenshot) and cannot be used in commands or signs.\n         */\n        action: ClickEventAction;\n        /**\n         * The URL, file, chat, command or book page used by the specified action. Note that commands must be prefixed with the usual \"/\" slash.\n         */\n        value: string;\n    };\n    hoverEvent?: {\n        /**\n         * The type of tooltip to show. Valid values are\n         * - \"show_text\" (shows raw JSON text),\n         * - \"show_item\" (shows the tooltip of an item that can have NBT tags),\n         * - \"show_entity\" (shows an entity's name, possibly its type, and its UUID).\n         */\n        action: HoverEventAction;\n        /**\n         * The formatting of this tag varies depending on the action. Note that \"show_text\" is the only action to support an Object as the value; all other action values are Strings and should thus be wrapped in quotes.\n         *\n         * - \"show_text\" can be either a raw string of text or an object with the same formatting as this base object. Note that clickEvent and hoverEvent do not function within the tooltip, but the formatting and extra tags still work.\n         * - \"show_item\" can be a string formatted like item NBT data. Contains the \"id\" tag, and optionally the \"Damage\" tag and \"tag\" tag (which is the same compound used as \"dataTag\" in the /give command).\n         * - \"show_entity\" can be string formatted like a compound with the string values \"type\" (such as \"Zombie\"), \"name\", and \"id\" (should be an entity UUID, but can actually be any string).\n         */\n        value: string | TextComponent;\n    };\n}\nexport declare type ClickEventAction = \"open_file\" | \"open_url\" | \"run_command\" | \"suggest_command\";\nexport declare type HoverEventAction = \"show_text\" | \"show_item\" | \"show_entity\";\nexport interface Style {\n    /**\n     * The friendly name of the color, like \\`light_purple\\` or \\`red\\`\n     */\n    color?: string;\n    bold?: boolean;\n    italic?: boolean;\n    underlined?: boolean;\n    strikethrough?: boolean;\n    obfuscated?: boolean;\n}\n/**\n * Get Minecraft style code for the style\n */\nexport declare function getStyleCode(style: TextComponent): string;\n/**\n * The renderable node\n */\nexport declare type RenderNode = {\n    /**\n     * The css style string\n     */\n    style: object;\n    /**\n     * The text component backed by\n     */\n    component: TextComponent;\n    /**\n     * Children\n     */\n    children: RenderNode[];\n};\n/**\n * Get suggest css style object for input style\n */\nexport declare function getSuggestedStyle(style: TextComponent | Style): object;\n/**\n * Render a text component into html style object\n * @returns the render node hint for html/css info\n */\nexport declare function render(src: TextComponent): RenderNode;\n/**\n * Flat all components (this component and its children) in this component by DFS into a list.\n * @param component The root component\n */\nexport declare function flat(component: TextComponent): TextComponent[];\n/**\n * Convert a text component to Minecraft specific formatted string like \\`§1colored§r\\`\n */\nexport declare function toFormattedString(comp: TextComponent): string;\n/**\n * Convert a formatted string to text component json\n * @param formatted The formatted string\n */\nexport declare function fromFormattedString(formatted: string): TextComponent;\n`;\nmodule.exports['@xmcl/text-component/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/unzip/index.d.ts'] = `/// <reference types=\"node\" />\nimport { Readable, Writable } from \"stream\";\nexport declare type OpenTarget = string | Buffer | number;\nexport interface ZipFileOptions {\n    decompress?: boolean | null;\n    decrypt?: boolean | null;\n    start?: number | null;\n    end?: number | null;\n}\nexport interface Entry {\n    readonly comment: string;\n    readonly compressedSize: number;\n    readonly compressionMethod: number;\n    readonly crc32: number;\n    readonly externalFileAttributes: number;\n    readonly extraFieldLength: number;\n    readonly extraFields: Array<{\n        id: number;\n        data: Buffer;\n    }>;\n    readonly fileCommentLength: number;\n    readonly fileName: string;\n    readonly fileNameLength: number;\n    readonly generalPurposeBitFlag: number;\n    readonly internalFileAttributes: number;\n    readonly lastModFileDate: number;\n    readonly lastModFileTime: number;\n    readonly relativeOffsetOfLocalHeader: number;\n    readonly uncompressedSize: number;\n    readonly versionMadeBy: number;\n    readonly versionNeededToExtract: number;\n    getLastModDate(): Date;\n    isEncrypted(): boolean;\n    isCompressed(): boolean;\n}\nexport interface Options {\n    lazyEntries?: boolean;\n    decodeStrings?: boolean;\n    validateEntrySizes?: boolean;\n    strictFileNames?: boolean;\n}\ninterface LazyOptions extends Options {\n    lazyEntries: true;\n}\ninterface CacheOptions extends Options {\n    lazyEntries?: false;\n}\nexport interface ZipFile {\n    readonly comment: string;\n    readonly decodeStrings: boolean;\n    readonly entryCount: number;\n    readonly fileSize: number;\n    readonly isOpen: boolean;\n    readonly validateEntrySizes: boolean;\n    readEntry(entry: Entry, options?: ZipFileOptions): Promise<Buffer>;\n    openEntry(entry: Entry, options?: ZipFileOptions): Promise<Readable>;\n    extractEntries(dest: string, options?: ExtractOptions): Promise<void>;\n    close(): void;\n}\nexport interface CachedZipFile extends ZipFile {\n    readonly entries: {\n        [name: string]: Entry | undefined;\n    };\n    filterEntries(filter: (e: Entry) => boolean): Entry[];\n}\nexport interface LazyZipFile extends ZipFile {\n    /**\n     * How many entries you have read\n     */\n    readonly entriesRead: number;\n    readonly readEntryCursor: boolean;\n    nextEntry(): Promise<Entry>;\n    /**\n     * When you know which entries you want, you can use this function to get the entries you want at once.\n     *\n     * For more complex requirement, please use walkEntries.\n     *\n     * @param entries The entries' names you want\n     */\n    filterEntries(entries: string[]): Promise<Entry[]>;\n    /**\n     * Start to walk all the unread entries.\n     * @param onEntry The function to handle an entry. Return true to stop the walk.\n     */\n    walkEntries(onEntry: (entry: Entry) => Promise<any> | boolean | void): Promise<void>;\n}\nexport interface ParseStream extends Writable {\n    wait(): Promise<LazyZipFile>;\n}\nexport interface ParseEntriesStream extends Writable {\n    wait(): Promise<CachedZipFile>;\n}\nexport interface ExtractStream extends Writable {\n    wait(): Promise<void>;\n}\nexport interface WalkEntriesStream extends Writable {\n    wait(): Promise<void>;\n}\nexport declare function open(target: OpenTarget, options: CacheOptions): Promise<CachedZipFile>;\nexport declare function open(target: OpenTarget, options: LazyOptions): Promise<LazyZipFile>;\nexport declare function open(target: OpenTarget, options: CacheOptions | LazyOptions): Promise<LazyZipFile | CachedZipFile>;\nexport declare function open(target: OpenTarget): Promise<CachedZipFile>;\nexport declare function createParseStream(options?: CacheOptions): ParseEntriesStream;\nexport declare function createParseStream(options?: LazyOptions): ParseStream;\nexport declare function createExtractStream(destination: string, options?: ExtractOptions): ExtractStream;\nexport declare function createWalkEntriesStream(onEntry: (entry: Entry) => Promise<any> | boolean | undefined): WalkEntriesStream;\n/**\n * Extract the zip file with a filter into a folder. The default filter is filter nothing, which will unzip all the content in zip.\n *\n * @param zipfile The zip file\n * @param dest The destination folder\n * @param filter The entry filter\n */\nexport declare function extract(openFile: OpenTarget, dest: string, options?: ExtractOptions): Promise<void>;\n/**\n * @param destinationRoot The root dir of extraction\n * @param entry The entry\n * @returns The relative path related to the root to extract\n */\nexport declare type EntryHandler = (destinationRoot: string, entry: Entry) => string | undefined | Promise<string | undefined>;\nexport interface ExtractOptions {\n    /**\n     * Only extract on these entries\n     */\n    entries?: string[];\n    /**\n     * The handler to decide the entry extraction path\n     */\n    entryHandler?: EntryHandler;\n    /**\n     * \\`true\\` to replace the if the entry destination existed, \\`false\\` to not replace.\n     * @default false\n     */\n    replaceExisted?: boolean;\n    /**\n     * The hook called after a entry extracted.\n     */\n    onAfterExtracted?: (destination: string, entry: Entry) => void;\n}\nexport {};\n`;\nmodule.exports['@xmcl/unzip/task/index.d.ts'] = `import { OpenTarget, ExtractOptions } from \"../index\";\nimport { Task } from \"@xmcl/task\";\n/**\n * This might be released as a seperate package, or removed later since this is a reversed dependency\n * @internal\n */\nexport declare function extractTaskFunction(openFile: OpenTarget, dest: string, options?: ExtractOptions): Task.Function<void>;\n`;\nmodule.exports['@xmcl/unzip/test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/user/auth.d.ts'] = `import { GameProfile } from \"./base\";\ndeclare type LoginWithUser = {\n    username: string;\n    password: string;\n    requestUser: true;\n} | {\n    username: string;\n    password: string;\n};\ndeclare type LoginWithoutUser = {\n    username: string;\n    password: string;\n    requestUser: false;\n};\ndeclare type LoginOption = LoginWithUser | LoginWithoutUser;\n/**\n * The auth response format.\n *\n * Please refer https://wiki.vg/Authentication\n */\nexport interface Authentication {\n    /**\n     * hexadecimal or JSON-Web-Token (unconfirmed) [The normal accessToken can be found in the payload of the JWT (second by '.' separated part as Base64 encoded JSON object), in key \"yggt\"]\n     */\n    accessToken: string;\n    /**\n     * identical to the one received\n     */\n    clientToken: string;\n    /**\n     * only present if the agent field was received\n     */\n    availableProfiles: GameProfile[];\n    /**\n     * only present if the agent field was received\n     */\n    selectedProfile: GameProfile;\n    /**\n     * only present if requestUser was true in the request payload\n     */\n    user?: {\n        id: string;\n        username: string;\n        email?: string;\n        registerIp?: string;\n        migratedFrom?: string;\n        migratedAt?: number;\n        registeredAt?: number;\n        passwordChangedAt?: number;\n        dateOfBirth?: number;\n        suspended?: boolean;\n        blocked?: boolean;\n        secured?: boolean;\n        migrated?: boolean;\n        emailVerified?: boolean;\n        legacyUser?: boolean;\n        verifiedByParent?: boolean;\n        properties?: object[];\n    };\n}\n/**\n * Random generate a new token by uuid v4. It can be client or auth token.\n * @returns a new token\n */\nexport declare function newToken(): string;\nexport interface AuthException {\n    error: \"Method Not Allowed\" | \"Not Not Found\" | \"ForbiddenOperationException\" | \"IllegalArgumentException\" | \"Unsupported Media Type\";\n    errorMessage: string;\n}\nexport declare class Authenticator {\n    readonly clientToken: string;\n    readonly api: YggdrasilAuthAPI;\n    /**\n     * Create a client for \\`Yggdrasil\\` service, given API and clientToken.\n     * @param clientToken The client token uuid. It will generate a new one if it's absent.\n     * @param api The api for this client.\n     */\n    constructor(clientToken: string, api: YggdrasilAuthAPI);\n    protected post(endpoint: string, payload: object): Promise<object | undefined>;\n    /**\n     * Login to the server by username and password. Notice that the auth server usually have the cooldown time for login.\n     * You have to wait for about a minute after one approch of login, to login again.\n     *\n     * @param option The login options, contains the username, password\n     * @throws This may throw the error object with \\`statusCode\\`, \\`statusMessage\\`, \\`type\\` (error type), and \\`message\\`\n     */\n    login(option: LoginOption): Promise<Authentication>;\n    /**\n     * Determine whether the access/client token pair is valid.\n     *\n     * @param option The access token\n     */\n    validate(option: {\n        accessToken: string;\n    }): Promise<boolean>;\n    /**\n     * Invalidate an access token and client token\n     *\n     * @param option The tokens\n     */\n    invalidate(option: {\n        accessToken: string;\n    }): Promise<void>;\n    /**\n     * Refresh the current access token with specific client token.\n     * Notice that the client token and access token must match.\n     *\n     * You can use this function to get a new token when your old token is expired.\n     *\n     * @param option The access token\n     */\n    refresh(option: {\n        accessToken: string;\n        requestUser?: boolean;\n    }): Promise<Pick<Authentication, \"accessToken\" | \"clientToken\">>;\n    signout(option: {\n        username: string;\n        password: string;\n    }): Promise<void>;\n}\nexport interface YggdrasilAuthAPI {\n    /**\n     * The host url, like https://xxx.xxx.com\n     */\n    readonly hostName: string;\n    /**\n     * Authenticate path, in the form of \\`/your-endpoint\\`.\n     * Use to login\n     */\n    readonly authenticate: string;\n    /**\n     * Use to refresh access token\n     */\n    readonly refresh: string;\n    /**\n     * Use to validate the user access token\n     */\n    readonly validate: string;\n    /**\n     * Use to logout user (invalidate user access token)\n     */\n    readonly invalidate: string;\n    /**\n     * Use to logout user (by username and password)\n     */\n    readonly signout: string;\n}\n/**\n * The default Mojang API\n */\nexport declare const AUTH_API_MOJANG: YggdrasilAuthAPI;\n/**\n * Login to the server by username and password. Notice that the auth server usually have the cooldown time for login.\n * You have to wait for about a minute after one approch of login, to login again.\n *\n * @param option The login options, contains the username, password and clientToken\n * @param api The API of the auth server\n * @throws This may throw the error object with \\`statusCode\\`, \\`statusMessage\\`, \\`type\\` (error type), and \\`message\\`\n */\nexport declare function login(option: LoginOption & {\n    clientToken?: string;\n}, api?: YggdrasilAuthAPI): Promise<Authentication>;\n/**\n * Refresh the current access token with specific client token.\n * Notice that the client token and access token must match.\n *\n * You can use this function to get a new token when your old token is expired.\n *\n * @param option The tokens\n * @param api The API of the auth server\n */\nexport declare function refresh(option: {\n    clientToken: string;\n    accessToken: string;\n    requestUser?: boolean;\n}, api?: YggdrasilAuthAPI): Promise<Pick<Authentication, \"accessToken\" | \"clientToken\">>;\n/**\n * Determine whether the access/client token pair is valid.\n *\n * @param option The tokens\n * @param api The API of the auth server\n */\nexport declare function validate(option: {\n    accessToken: string;\n    clientToken?: string;\n}, api?: YggdrasilAuthAPI): Promise<boolean>;\n/**\n * Invalidate an access/client token pair\n *\n * @param option The tokens\n * @param api The API of the auth server\n */\nexport declare function invalidate(option: {\n    accessToken: string;\n    clientToken: string;\n}, api?: YggdrasilAuthAPI): Promise<void>;\n/**\n * Signout user by username and password\n *\n * @param option The username and password\n * @param api The API of the auth server\n */\nexport declare function signout(option: {\n    username: string;\n    password: string;\n}, api?: YggdrasilAuthAPI): Promise<void>;\n/**\n * Create an offline auth. It'll ensure the user game profile's \\`uuid\\` is the same for the same \\`username\\`.\n *\n * @param username The username you want to have in-game.\n */\nexport declare function offline(username: string): Authentication;\nexport {};\n`;\nmodule.exports['@xmcl/user/auth.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/user/base.d.ts'] = `/**\n * The game profile of the user.\n *\n * In auth response, it will usually carry the \\`userId\\`, \\`createdAt\\` properties.\n *\n * In \\`lookup\\` function, it will carry the \\`properties\\` property.\n */\nexport interface GameProfile {\n    /**\n     * game profile unique id\n     */\n    id: string;\n    /**\n     * This is in game displayed name\n     */\n    name: string;\n    properties?: {\n        [name: string]: string;\n    };\n    userId?: string;\n    createdAt?: number;\n    legacyProfile?: boolean;\n    suspended?: boolean;\n    paid?: boolean;\n    migrated?: boolean;\n    legacy?: boolean;\n}\nexport interface GameProfileWithProperties extends GameProfile {\n    properties: {\n        [name: string]: string;\n    };\n}\nexport declare namespace GameProfile {\n    interface TexturesInfo {\n        /**\n         * java time in ms\n         */\n        timestamp: number;\n        /**\n         * player name\n         */\n        profileName: string;\n        /**\n         * player id\n         */\n        profileId: string;\n        textures: {\n            SKIN?: Texture;\n            CAPE?: Texture;\n            ELYTRA?: Texture;\n        };\n    }\n    /**\n     * The data structure that hold the texture\n     */\n    interface Texture {\n        url: string;\n        metadata?: {\n            model?: \"slim\" | \"steve\";\n            [key: string]: any;\n        };\n    }\n    namespace Texture {\n        function isSlim(o: Texture): boolean;\n        function getModelType(o: Texture): \"slim\" | \"steve\";\n    }\n}\n/**\n * Abstract layer for http requester.\n */\nexport declare type HttpRequester = (option: {\n    url: string;\n    method: string;\n    headers: {\n        [key: string]: string;\n    };\n    /**\n     * Search string\n     */\n    search?: {\n        [key: string]: string | string[] | undefined;\n    };\n    /**\n     * Either form multi part or json. Default is json.\n     */\n    bodyType?: \"formMultiPart\" | \"json\" | \"search\";\n    body?: FormItems | object | Record<string, string>;\n}) => Promise<{\n    body: string;\n    statusMessage: string;\n    statusCode: number;\n}>;\nexport declare type Verify = (value: string, signature: string, pemKey: string) => Promise<boolean>;\nexport interface ItemBlob {\n    type: string;\n    value: Uint8Array;\n}\nexport interface FormItems {\n    [name: string]: ItemBlob | string;\n}\n`;\nmodule.exports['@xmcl/user/index.d.ts'] = `export * from \"./auth\";\nexport { GameProfile, GameProfileWithProperties } from \"./base\";\nexport * from \"./mojang\";\nexport * from \"./service\";\n`;\nmodule.exports['@xmcl/user/mojang.d.ts'] = `/**\n * Users defined question when they register this account\n *\n * The question id, content mapping is:\n *\n * 1. What is your favorite pet's name?\n * 2. What is your favorite movie?\n * 3. What is your favorite author's last name?\n * 4. What is your favorite artist's last name?\n * 5. What is your favorite actor's last name?\n * 6. What is your favorite activity?\n * 7. What is your favorite restaurant?\n * 8. What is the name of your favorite cartoon?\n * 9. What is the name of the first school you attended?\n * 10. What is the last name of your favorite teacher?\n * 11. What is your best friend's first name?\n * 12. What is your favorite cousin's name?\n * 13. What was the first name of your first girl/boyfriend?\n * 14. What was the name of your first stuffed animal?\n * 15. What is your mother's middle name?\n * 16. What is your father's middle name?\n * 17. What is your oldest sibling's middle name?\n * 18. In what city did your parents meet?\n * 19. In what hospital were you born?\n * 20. What is your favorite team?\n * 21. How old were you when you got your first computer?\n * 22. How old were you when you got your first gaming console?\n * 23. What was your first video game?\n * 24. What is your favorite card game?\n * 25. What is your favorite board game?\n * 26. What was your first gaming console?\n * 27. What was the first book you ever read?\n * 28. Where did you go on your first holiday?\n * 29. In what city does your grandmother live?\n * 30. In what city does your grandfather live?\n * 31. What is your grandmother's first name?\n * 32. What is your grandfather's first name?\n * 33. What is your least favorite food?\n * 34. What is your favorite ice cream flavor?\n * 35. What is your favorite ice cream flavor?\n * 36. What is your favorite place to visit?\n * 37. What is your dream job?\n * 38. What color was your first pet?\n * 39. What is your lucky number?s\n *\n */\nexport interface MojangChallenge {\n    readonly answer: {\n        id: number;\n    };\n    readonly question: {\n        id: number;\n        question: string;\n    };\n}\nexport interface MojangChallengeResponse {\n    id: number;\n    answer: string;\n}\n/**\n * Check if user need to verify its identity. If this return false, should perform such operations:\n * 1. call \\`getChallenges\\` get all questions\n * 2. let user response questions\n * 3. call \\`responseChallenges\\` to send user responsed questions, if false, redo \\`2\\` step.\n *\n * If you don't let user response challenges when this return false. You won't be able to get/set user texture from Mojang server.\n *\n * *(This only work for Mojang account. Third party definitly doesn't have such thing)*\n * @param accessToken You user access token.\n */\nexport declare function checkLocation(accessToken: string): Promise<boolean>;\n/**\n * Get the user set challenge to response.\n *\n * @param accessToken The user access token\n * @returns User pre-defined questions\n */\nexport declare function getChallenges(accessToken: string): Promise<MojangChallenge[]>;\n/**\n * Response the challeges from \\`getChallenges\\`.\n *\n * @param accessToken The access token\n * @param responses Your responses\n * @returns True for correctly responsed all questions\n */\nexport declare function responseChallenges(accessToken: string, responses: MojangChallengeResponse[]): Promise<boolean>;\n`;\nmodule.exports['@xmcl/user/mojang.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/user/service.d.ts'] = `import { GameProfile, GameProfileWithProperties } from \"./base\";\nexport interface ProfileLookupException {\n    /**\n     * - statusCode=204 -> error=\"NoPlayerFound\"\n     * - statusCode=400 -> error=\"IllegalArgumentException\" (parsed from body)\n     * - statusCode=other -> error=statusCode.toString()\n     */\n    error: \"NoPlayerFoundException\" | \"IllegalArgumentException\" | \"GeneralException\";\n    errorMessage?: string | \"Invalid timestamp.\";\n    statusCode?: number;\n    statusMessage?: string;\n}\nexport interface ProfileServiceAPI {\n    /**\n     * The PEM public key\n     */\n    publicKey?: string;\n    /**\n     * Full url to query profile by uuid. Place the uuid as \\`\\${uuid}\\` in this url\n     */\n    profile: string;\n    /**\n     * Full url to query profile by name. Place the name as \\`\\${name}\\` in this url\n     */\n    profileByName: string;\n    /**\n     * Full url to set texture by profile uuid and texture type. Place uuid as \\`\\${uuid}\\` and type as \\`\\${type}\\`\n     */\n    texture: string;\n}\nexport declare namespace ProfileServiceAPI {\n    /**\n     * Replace \\`\\${uuid}\\` string into uuid param\n     * @param api The api\n     * @param uuid The uuid will be replaced\n     */\n    function getProfileUrl(api: ProfileServiceAPI, uuid: string): string;\n    /**\n     * Replace \\`\\${name}\\` string into name param\n     * @param api The api\n     * @param name The name will be replaced\n     */\n    function getProfileByNameUrl(api: ProfileServiceAPI, name: string): string;\n    /**\n     * Replace uuid string into \\`\\${uuid}\\`, and type string into \\`\\${type}\\`\n     * @param api The api\n     * @param uuid The uuid string\n     * @param type The type string\n     */\n    function getTextureUrl(api: ProfileServiceAPI, uuid: string, type: string): string;\n}\n/**\n * The default Mojang API\n */\nexport declare const PROFILE_API_MOJANG: ProfileServiceAPI;\n/**\n * Get all the textures of this GameProfile and cache them.\n *\n * @param profile The game profile from the profile service\n * @param cache Should we cache the texture into url? Default is \\`true\\`.\n */\nexport declare function getTextures(profile: GameProfile): GameProfile.TexturesInfo | undefined;\n/**\n * Fetch the GameProfile by uuid.\n *\n * @param uuid The unique id of user/player\n * @param option the options for this function\n */\nexport declare function lookup(uuid: string, option?: {\n    api?: ProfileServiceAPI;\n    unsigned?: boolean;\n}): Promise<GameProfileWithProperties>;\n/**\n * Look up the GameProfile by username in game.\n * This will return the UUID of the name at the timestamp provided.\n * \\`?at=0\\` can be used to get the UUID of the original user of that username, but, it only works if the name was changed at least once, or if the account is legacy.\n\n * The timestamp is a UNIX timestamp (without milliseconds)\n * When the at parameter is not sent, the current time is used\n * @param name The username in game.\n * @param option the options of this function\n * @throws ProfileLookupException\n */\nexport declare function lookupByName(name: string, option?: {\n    api?: ProfileServiceAPI;\n    timestamp?: number;\n}): Promise<GameProfile>;\nexport interface SetTextureOption {\n    accessToken: string;\n    uuid: string;\n    type: \"skin\" | \"cape\" | \"elytra\";\n    texture?: {\n        url: string;\n        metadata?: {\n            model?: \"slim\" | \"steve\";\n            [key: string]: any;\n        };\n    } | {\n        data: Uint8Array;\n        metadata?: {\n            model?: \"slim\" | \"steve\";\n            [key: string]: any;\n        };\n    };\n}\n/**\n * Set texture by access token and uuid.\n * If the texture is undefined, it will clear the texture to default steve.\n */\nexport declare function setTexture(option: SetTextureOption, api?: ProfileServiceAPI): Promise<void>;\n/**\n * A lookuper will maintain your last time of lookup. It will prevent the lookup frequency exceed the rate limit\n */\nexport declare class ProfileLookuper {\n    readonly api: ProfileServiceAPI;\n    /**\n     * The rate limit of this lookuper\n     */\n    readonly rateLimit: number;\n    protected lookupRecord: Record<string, {\n        lastLookupTime: number;\n        deferredLookup: Promise<any> | undefined;\n    }>;\n    constructor(api: ProfileServiceAPI, \n    /**\n     * The rate limit of this lookuper\n     */\n    rateLimit?: number);\n    lookup(uuid: string): Promise<GameProfileWithProperties>;\n}\n`;\nmodule.exports['@xmcl/user/service.test.d.ts'] = `export {};\n`;\nmodule.exports['@xmcl/user/util/base.d.ts'] = `/**\n * Abstract layer for http requester.\n */\nexport declare type HttpRequester = (option: {\n    url: string;\n    method: string;\n    headers: {\n        [key: string]: string;\n    };\n    /**\n     * Search string\n     */\n    search?: {\n        [key: string]: string | string[] | undefined;\n    };\n    /**\n     * Either form multi part or json. Default is json.\n     */\n    bodyType?: \"formMultiPart\" | \"json\" | \"search\";\n    body?: FormItems | object | Record<string, string>;\n}) => Promise<{\n    body: string;\n    statusMessage: string;\n    statusCode: number;\n}>;\nexport interface ItemBlob {\n    type: string;\n    value: Uint8Array;\n}\nexport interface FormItems {\n    [name: string]: ItemBlob | string;\n}\n`;\nmodule.exports['@xmcl/user/util/index.browser.d.ts'] = `import { HttpRequester } from \"./base\";\nexport declare const httpRequester: HttpRequester;\nexport declare function verify(data: string, signature: string, pemKey: string | Uint8Array): Promise<boolean>;\nexport declare function decodeBase64(b: string): string;\n`;\nmodule.exports['@xmcl/user/util/index.d.ts'] = `import { HttpRequester } from \"./base\";\nexport declare const httpRequester: HttpRequester;\nexport declare function verify(data: string, signature: string, pemKey: string | Uint8Array): Promise<boolean>;\nexport declare function decodeBase64(s: string): string;\n`;\nmodule.exports['@xmcl/world/index.d.ts'] = `import { FileSystem } from \"@xmcl/system\";\nimport Long from \"long\";\nexport declare class WorldReader {\n    private fs;\n    static create(path: string | Uint8Array): Promise<WorldReader>;\n    constructor(fs: FileSystem);\n    /**\n     * Get region data frame\n     * @param chunkX The x value of chunk coord\n     * @param chunkZ The z value of chunk coord\n     */\n    getRegionData(chunkX: number, chunkZ: number): Promise<RegionDataFrame>;\n    /**\n     * Read the level data\n     */\n    getLevelData(): Promise<LevelDataFrame>;\n    getPlayerData(): Promise<PlayerDataFrame[]>;\n    getAdvancementsData(): Promise<AdvancementDataFrame[]>;\n}\n/**\n * The chunk index is a number in range [0, 4096), which is mapped position from (0,0,0) to (16,16,16) inside the chunk.\n */\nexport declare type ChunkIndex = number;\n/**\n * Get chunk index from position.\n * All x, y, z should be in range [0, 16)\n *\n * @param x The position x. Should be in range [0, 16)\n * @param y The position y. Should be in range [0, 16)\n * @param z The position z. Should be in range [0, 16)\n */\nexport declare function getIndexInChunk(x: number, y: number, z: number): ChunkIndex;\n/**\n * Get in-chunk coordination from chunk index\n * @param index The index number in chunk\n */\nexport declare function getCoordFromIndex(index: ChunkIndex): {\n    x: number;\n    y: number;\n    z: number;\n};\nexport declare namespace RegionReader {\n    /**\n     * Get a chunk section in a region by chunk Y value.\n     * @param region The region\n     * @param chunkY The y value of the chunk. It should be from [0, 16)\n     */\n    function getSection(region: RegionDataFrame, chunkY: number): RegionSectionDataFrame;\n    /**\n     * Walk through all the position in this chunk and emit all the id in every position.\n     * @param section The chunk section\n     * @param reader The callback which will receive the position + state id.\n     */\n    function walkBlockStateId(section: RegionSectionDataFrame, reader: (x: number, y: number, z: number, id: number) => void): void;\n    /**\n     * Seek the section and get the block state id from the section.\n     * @param section The section\n     * @param index The chunk index\n     */\n    function seekBlockStateId(section: NewRegionSectionDataFrame | LegacyRegionSectionDataFrame, index: ChunkIndex): number;\n    /**\n     * Seek the block state data from new region format.\n     * @param section The new region section\n     * @param index The chunk index, which is a number in range [0, 4096)\n     */\n    function seekBlockState(section: NewRegionSectionDataFrame, index: ChunkIndex): BlockStateData;\n}\n/**\n * The Minecraft provided block state info. Only presented in the version >= 1.13 chunk data.\n */\nexport interface BlockStateData {\n    Name: string;\n    Properties: {\n        [key: string]: string;\n    };\n}\nexport declare enum GameType {\n    NON = -1,\n    SURVIVAL = 0,\n    CREATIVE = 1,\n    ADVENTURE = 2,\n    SPECTATOR = 3\n}\nexport interface PlayerDataFrame {\n    UUIDLeast: Long;\n    UUIDMost: Long;\n    DataVersion: number;\n    Pos: [number, number, number];\n    Rotation: [number, number, number];\n    Motion: [number, number, number];\n    Dimension: number;\n    SpawnX: number;\n    SpawnY: number;\n    SpawnZ: number;\n    playerGameType: number;\n    Attributes: Array<{\n        Base: number;\n        Name: string;\n    }>;\n    HurtTime: number;\n    DeathTime: number;\n    HurtByTimestamp: number;\n    SleepTimer: number;\n    SpawnForced: number;\n    FallDistance: number;\n    SelectedItemSlot: number;\n    seenCredits: number;\n    Air: number;\n    AbsorptionAmount: number;\n    Invulnerable: number;\n    FallFlying: number;\n    PortalCooldown: number;\n    Health: number;\n    OnGround: number;\n    XpLevel: number;\n    Score: number;\n    Sleeping: number;\n    Fire: number;\n    XpP: number;\n    XpSeed: number;\n    XpTotal: number;\n    foodLevel: number;\n    foodExhaustionLevel: number;\n    foodTickTimer: number;\n    foodSaturationLevel: number;\n    recipeBook: {\n        isFilteringCraftable: number;\n        isGuiOpen: number;\n    };\n    abilities: {\n        invulnerable: number;\n        mayfly: number;\n        instabuild: number;\n        walkSpeed: number;\n        mayBuild: number;\n        flying: number;\n        flySpeed: number;\n    };\n}\ndeclare type StringBoolean = \"true\" | \"false\";\nexport interface LevelDataFrame {\n    BorderCenterX: number;\n    BorderCenterZ: number;\n    BorderDamagePerBlock: number;\n    BorderSafeZone: number;\n    BorderSize: number;\n    BorderSizeLerpTarget: number;\n    BorderSizeLerpTime: Long;\n    BorderWarningBlocks: number;\n    BorderWarningTime: number;\n    DataVersion: number;\n    DayTime: Long;\n    Difficulty: number;\n    DifficultyLocked: number;\n    DimensionData: {\n        [dimension: number]: {\n            DragonFight: {\n                Gateways: number[];\n                DragonKilled: number;\n                PreviouslyKilled: number;\n                ExitPortalLocation?: [number, number, number];\n            };\n        };\n    };\n    GameRules: {\n        doTileDrops: StringBoolean;\n        doFireTick: StringBoolean;\n        gameLoopFunction: string;\n        maxCommandChainLength: string;\n        reducedDebugInfo: string;\n        naturalRegeneration: string;\n        disableElytraMovementCheck: string;\n        doMobLoot: StringBoolean;\n        announceAdvancements: string;\n        keepInventory: StringBoolean;\n        doEntityDrops: StringBoolean;\n        doLimitedCrafting: StringBoolean;\n        mobGriefing: StringBoolean;\n        randomTickSpeed: string;\n        commandBlockOutput: string;\n        spawnRadius: string;\n        doMobSpawning: StringBoolean;\n        maxEntityCramming: string;\n        logAdminCommands: string;\n        spectatorsGenerateChunks: string;\n        doWeatherCycle: StringBoolean;\n        sendCommandFeedback: string;\n        doDaylightCycle: StringBoolean;\n        showDeathMessages: StringBoolean;\n    };\n    GameType: GameType;\n    LastPlayed: Long;\n    LevelName: string;\n    MapFeatures: number;\n    Player: PlayerDataFrame;\n    RandomSeed: Long;\n    readonly SizeOnDisk: Long;\n    SpawnX: number;\n    SpawnY: number;\n    SpawnZ: number;\n    Time: Long;\n    Version: {\n        Snapshot: number;\n        Id: number;\n        Name: string;\n    };\n    allowCommands: number;\n    clearWeatherTime: number;\n    generatorName: \"default\" | \"flat\" | \"largeBiomes\" | \"amplified\" | \"buffet\" | \"debug_all_block_states\" | string;\n    generatorOptions: string;\n    generatorVersion: number;\n    hardcore: number;\n    initialized: number;\n    rainTime: number;\n    raining: number;\n    thunderTime: number;\n    thundering: number;\n    version: number;\n}\nexport interface AdvancementDataFrame {\n    display?: {\n        background?: string;\n        description: object | string;\n        show_toast: boolean;\n        announce_to_chat: boolean;\n        hidden: boolean;\n    };\n    parent?: string;\n    criteria: {\n        [name: string]: {\n            trigger: string;\n            conditions: {};\n        };\n    };\n    requirements: string[];\n    rewards: {\n        recipes: string[];\n        loot: string[];\n        experience: number;\n        function: string;\n    };\n}\nexport interface ItemStackDataFrame {\n    Slot: number;\n    id: string;\n    Count: number;\n    Damage: number;\n    tag?: {\n        Unbreakable: number;\n        CanDestroy: string[];\n        CanPlaceOn: string[];\n        BlockEntityTag: {};\n        ench: Array<{\n            id: number;\n            lvl: number;\n        }>;\n        StoredEnchantments: Array<{\n            id: number;\n            lvl: number;\n        }>;\n        RepairCost: number;\n        AttributeModifiers: Array<{\n            AttributeName: string;\n            Name: string;\n            Slot: string;\n            Operation: number;\n            Amount: number;\n            UUIDMost: Long;\n            UUIDLeast: Long;\n        }>;\n        CustomPotionEffects: Array<{\n            Id: number;\n            Amplifier: number;\n            Duration: number;\n            Ambient: number;\n            ShowParticles: number;\n        }>;\n        Potion: string;\n        CustomPotionColor: number;\n        display: Array<{\n            color: number;\n            Name: string;\n            LocName: string;\n            Lore: string[];\n        }>;\n        HideFlags: number;\n        resolved: number;\n        /**\n         * The copy tier of the book. 0 = original, number = copy of original, number = copy of copy, number = tattered.\n         * If the value is greater than number, the book cannot be copied. Does not exist for original books.\n         * If this tag is missing, it is assumed the book is an original. 'Tattered' is unused in normal gameplay, and functions identically to the 'copy of copy' tier.\n         */\n        generation: number;\n        author: string;\n        title: string;\n        /**\n         * A single page in the book. If generated by writing in a book and quill in-game, each page is a string in double quotes and uses the escape sequences \\\" for a double quote,\n         * for a line break and \\\\ for a backslash. If created by commands or external tools, a page can be a serialized JSON object or an array of strings and/or objects (see Commands#Raw JSON text) or an unescaped string.\n         */\n        pages: string[];\n    };\n}\nexport interface TileEntityDataFrame {\n    x: number;\n    y: number;\n    z: number;\n    Items: ItemStackDataFrame[];\n    id: string;\n    [key: string]: any;\n}\nexport declare type LegacyRegionSectionDataFrame = {\n    Blocks: Array<number>;\n    Data: Array<number>;\n    Add: Array<number>;\n    BlockLight: number[];\n    SkyLight: number[];\n    Y: number;\n};\nexport declare type NewRegionSectionDataFrame = {\n    BlockStates: Long[];\n    Palette: Array<BlockStateData>;\n    Data: number[];\n    BlockLight: number[];\n    SkyLight: number[];\n    Y: number;\n};\nexport declare type RegionSectionDataFrame = LegacyRegionSectionDataFrame | NewRegionSectionDataFrame;\nexport interface RegionDataFrame {\n    Level: {\n        xPos: number;\n        zPos: number;\n        LightPopulated: number;\n        LastUpdate: Long;\n        InhabitedTime: Long;\n        HeightMap: number[];\n        Biomes: number[];\n        Entities: object[];\n        TileEntities: TileEntityDataFrame[];\n        Sections: RegionSectionDataFrame[];\n    };\n    DataVersion: number;\n    ForgeDataVersion?: number;\n}\nexport {};\n`;\nmodule.exports['@xmcl/world/test.d.ts'] = `export {};\n`;","module.exports['common'] = `import { launch } from '@xmcl/core';\nimport { login, Authentication, offline } from '@xmcl/user';\n\nlet authentication: Authentication = offline(\"offline-user-name\");\nlet gamePath: string = \"your game path\";\nlet javaPath: string = \"your java path\";\nlet version: string = \"1.14.4\";\n\nasync function userLogin(username: string, password: string) {\n    authentication = await login({ username, password });\n}\n\nasync function gameLaunch() {\n    const process = await launch({\n        accessToken: authentication.accessToken,\n        gamePath,\n        javaPath,\n        version,\n        gameProfile: authentication.selectedProfile,\n    });\n    process.stdout.on('data', (b) => {\n        // print mc output\n        console.log(b.toString());\n    });\n    process.stderr.on('data', (b) => {\n        // print mc err output\n        console.log(b.toString());\n    });\n}\n\n`;\nmodule.exports['installer'] = `import { Installer } from '@xmcl/installer';\nimport { Task } from \"@xmcl/task\";\n\nlet versionMetaList: Installer.VersionList;\nlet minecraftLocation: string; \"my/path/to/minecraft\"\n\nasync function updateVersionList() {\n    versionMetaList = await Installer.getVersionList({ original: versionMetaList });\n}\n\nasync function installVersion(versionMeta: Installer.Version) {\n    await Installer.install(\"client\", versionMeta, minecraftLocation);\n}\n\nasync function installButMonitorProgress(versionMeta: Installer.Version) {\n    const task = Installer.installTask(\"client\", versionMeta, minecraftLocation);\n    const handle = Task.execute(task);\n    handle.on(\"execute\", (taskState, parent) => {\n        console.log(\\`\\${taskState.name} executed!\\`);\n    });\n    handle.on(\"update\", ({ progress, total, message }, state) => {\n        // path is the full name in format of \\`thisTask.path = parentTask.path.thisTask.name\\`\n        console.log(\\`\\${state.path} \\${progress} \\${total}, \\${message}\\`);\n        // you might want to update this info to your UI !\n    });\n    const result = await handle.wait();\n    return result;\n}\n\n\n`;\nmodule.exports['lab'] = `// core packages\n\nimport { Installer } from '@xmcl/installer';\nimport { launch, Version } from '@xmcl/core';\nimport { login } from '@xmcl/user';\n\n// additional packages\n\nimport { Forge } from '@xmcl/mod-parser';\nimport { ResourcePack } from '@xmcl/resourcepack';\nimport { ResourceManager } from '@xmcl/resource-manager';\nimport { parse } from '@xmcl/gamesetting';\nimport { TextComponent } from '@xmcl/text-component';\nimport { WorldReader } from '@xmcl/world';\n\n// three shaking usage\n// not all packages have this feature\nimport { readModMetaData } from '@xmcl/mod-parser/forge';\n\nreadModMetaData; // equal to Forge.readModMetaData`;\nmodule.exports['skin'] = `/// suppose you are on electron MAIN process ///\n\nimport { login, Authentication, offline, getTextures, lookup, GameProfileWithProperties, GameProfile } from '@xmcl/user';\n\nlet authentication: Authentication = offline(\"offline-user-name\");\n\nexport async function userLogin(username: string, password: string) {\n    authentication = await login({ username, password });\n}\n\nasync function setupPlayerSkin() {\n    const profile: GameProfileWithProperties = await lookup(authentication.selectedProfile.id);\n    const textureInf = getTextures(profile);\n    const playerSkin = textureInf.textures.SKIN;\n    if (playerSkin) {\n        sendPlayerSkinUrlToRenderer(playerSkin.url, GameProfile.Texture.isSlim(playerSkin));\n    }\n}\n\nfunction sendPlayerSkinUrlToRenderer(url: string, isSlim: boolean) {\n    // you implement your way to send json object to the renderer process\n}\n\n/// suppose you are on electron RENDERER process ///\n\nimport { PlayerModel } from '@xmcl/model';\n\nlet model: PlayerModel = new PlayerModel();\nlet object3D = model.playerObject3d; // THREEjs object 3d\n// add this object 3d to your three js scene to display\n\nfunction onPlayerSkinUrlRecieve(url: string, isSlim: boolean) {\n    model.setSkin(url, isSlim);\n}\n`;","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var getBundleURL = require('./bundle-url').getBundleURL;\n\nfunction loadBundlesLazy(bundles) {\n  if (!Array.isArray(bundles)) {\n    bundles = [bundles]\n  }\n\n  var id = bundles[bundles.length - 1];\n\n  try {\n    return Promise.resolve(require(id));\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return new LazyPromise(function (resolve, reject) {\n        loadBundles(bundles.slice(0, -1))\n          .then(function () {\n            return require(id);\n          })\n          .then(resolve, reject);\n      });\n    }\n\n    throw err;\n  }\n}\n\nfunction loadBundles(bundles) {\n  return Promise.all(bundles.map(loadBundle));\n}\n\nvar bundleLoaders = {};\nfunction registerBundleLoader(type, loader) {\n  bundleLoaders[type] = loader;\n}\n\nmodule.exports = exports = loadBundlesLazy;\nexports.load = loadBundles;\nexports.register = registerBundleLoader;\n\nvar bundles = {};\nfunction loadBundle(bundle) {\n  var id;\n  if (Array.isArray(bundle)) {\n    id = bundle[1];\n    bundle = bundle[0];\n  }\n\n  if (bundles[bundle]) {\n    return bundles[bundle];\n  }\n\n  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();\n  var bundleLoader = bundleLoaders[type];\n  if (bundleLoader) {\n    return bundles[bundle] = bundleLoader(getBundleURL() + bundle)\n      .then(function (resolved) {\n        if (resolved) {\n          module.bundle.register(id, resolved);\n        }\n\n        return resolved;\n      }).catch(function(e) {\n        delete bundles[bundle];\n        \n        throw e;\n      });\n  }\n}\n\nfunction LazyPromise(executor) {\n  this.executor = executor;\n  this.promise = null;\n}\n\nLazyPromise.prototype.then = function (onSuccess, onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.then(onSuccess, onError)\n};\n\nLazyPromise.prototype.catch = function (onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.catch(onError)\n};\n","import definitions from './definitions';\nimport scenarios from './scenarios';\n\nself.MonacoEnvironment = {\n    getWorkerUrl: function (moduleId, label) {\n        if (label === 'json') {\n            return './json.worker.js';\n        }\n        if (label === 'html') {\n            return './html.worker.js';\n        }\n        if (label === 'typescript' || label === 'javascript') {\n            return './ts.worker.js';\n        }\n        return './editor.worker.js';\n    },\n};\n\nimport('monaco-editor').then((monaco) => {\n\n    monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n        target: monaco.languages.typescript.ScriptTarget.ES2015,\n        allowNonTsExtensions: true,\n        moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n        module: monaco.languages.typescript.ModuleKind.CommonJS,\n    });\n\n    for (const key of Object.keys(definitions)) {\n        const modulePath = `file:///node_modules/${key}`;\n\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(\n            definitions[key],\n            modulePath,\n        );\n    }\n\n    const models = {\n    }\n\n    for (const key of Object.keys(scenarios)) {\n        models[key] = monaco.editor.createModel(\n            scenarios[key],\n            'typescript',\n            monaco.Uri.parse(`${key}.ts`)\n        );\n    }\n\n    const editor = monaco.editor.create(document.getElementById('editor'), {\n        model: models.common,\n        language: 'typescript',\n        theme: \"vs-dark\",\n        automaticLayout: true,\n    });\n\n    $('#code-sample').dropdown({\n        onChange: function (src, _, elem) {\n            editor.setModel(models[elem.attr('value')]);\n        }\n    });\n\n    function proxyOfAny() {\n        return new Proxy(() => { }, {\n            get(target, key) {\n                return proxyOfAny();\n            },\n            apply() {\n                return proxyOfAny();\n            },\n            construct() {\n                return proxyOfAny();\n            }\n        });\n    }\n\n    function require(m) {\n        console.log(`Require ${m}`);\n        return proxyOfAny();\n    }\n\n    const context = {\n        require,\n    }\n\n    function evalInScope(js) {\n        //# Return the results of the in-line anonymous function we .call with the passed context\n        return function () { return eval(js); }.call(context);\n    }\n\n    editor.addCommand(monaco.KeyCode.F2, () => {\n        monaco.languages.typescript.getTypeScriptWorker()\n            .then(function (worker) {\n                worker(models.common.uri).then(function (client) {\n                    client.getEmitOutput(models.common.uri.toString()).then(function (r) {\n                        // const code = r.outputFiles[0].text;\n                        const code = `let localRequire = require; require = this.require; ${r.outputFiles[0].text}; require = localRequire;`;\n                        evalInScope(code)\n                    });\n                });\n            });\n    });\n\n});\n\n\n\n// R((require, modules, exports) => {\n\n// });","module.exports = function loadCSSBundle(bundle) {\n  return new Promise(function (resolve, reject) {\n    var link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = bundle;\n    link.onerror = function (e) {\n      link.onerror = link.onload = null;\n      reject(e);\n    };\n\n    link.onload = function () {\n      link.onerror = link.onload = null;\n      resolve();\n    };\n\n    document.getElementsByTagName('head')[0].appendChild(link);\n  });\n};\n","module.exports = function loadJSBundle(bundle) {\n  return new Promise(function (resolve, reject) {\n    var script = document.createElement('script');\n    script.async = true;\n    script.type = 'text/javascript';\n    script.charset = 'utf-8';\n    script.src = bundle;\n    script.onerror = function (e) {\n      script.onerror = script.onload = null;\n      reject(e);\n    };\n\n    script.onload = function () {\n      script.onerror = script.onload = null;\n      resolve();\n    };\n\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n};\n"]}